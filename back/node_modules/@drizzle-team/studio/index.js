"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc4) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc4 = __getOwnPropDesc(from, key)) || desc4.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  queryEngineForSetup: () => queryEngineForSetup
});
module.exports = __toCommonJS(src_exports);

// src/sqlite.ts
var import_drizzle_orm2 = require("drizzle-orm");
var import_sqlite_core2 = require("drizzle-orm/sqlite-core");

// src/common.ts
var import_drizzle_orm = require("drizzle-orm");
var import_mysql_core = require("drizzle-orm/mysql-core");
var import_pg_core = require("drizzle-orm/pg-core");
var import_sqlite_core = require("drizzle-orm/sqlite-core");
function filtersToSQL(filters) {
  return Object.entries(filters).reduce(
    (acc, [key, value]) => {
      if (key === "and") {
        return (0, import_drizzle_orm.and)(acc, ...value.map((v) => filtersToSQL(v)));
      }
      if (key === "or") {
        return (0, import_drizzle_orm.or)(acc, ...value.map((v) => filtersToSQL(v)));
      }
      if (key === "op") {
        const op = value;
        return import_drizzle_orm.sql.fromList([
          import_drizzle_orm.sql.identifier(op[0]),
          import_drizzle_orm.sql` `,
          import_drizzle_orm.sql.raw(op[1]),
          import_drizzle_orm.sql` `,
          op[2]
        ]);
      }
      throw new Error(`Unknown filter key: ${key}`);
    },
    void 0
  );
}
var convertToTsColumns = (data, columnNamesMap) => {
  return Object.fromEntries(
    Object.entries(data).map((it) => {
      const { name: tsName, mapper } = columnNamesMap[it[0]];
      if (!tsName)
        throw new Error(`No column name '${it[0]}'`);
      return [tsName, mapper(it[1])];
    })
  );
};
var extractRelations = (tablesConfig) => {
  const rels = Object.values(tablesConfig.tables).map(
    (it) => Object.entries(it.relations).map((it1) => {
      const normalized = (0, import_drizzle_orm.normalizeRelation)(
        tablesConfig.tables,
        tablesConfig.tableNamesMap,
        it1[1]
      );
      const rel = it1[1];
      const refTableName = rel.referencedTableName;
      const refTable = rel.referencedTable;
      const fields = normalized.fields.map((it2) => it2.name).flat();
      const refColumns = normalized.references.map((it2) => it2.name).flat();
      let refSchema;
      if ((0, import_drizzle_orm.is)(refTable, import_pg_core.PgTable)) {
        refSchema = (0, import_pg_core.getTableConfig)(refTable).schema;
      } else if ((0, import_drizzle_orm.is)(refTable, import_mysql_core.MySqlTable)) {
        refSchema = (0, import_mysql_core.getTableConfig)(refTable).schema;
      } else if ((0, import_drizzle_orm.is)(refTable, import_sqlite_core.SQLiteTable)) {
        refSchema = void 0;
      } else {
        throw new Error("unsupported dialect");
      }
      return {
        name: it1[0],
        table: it.dbName,
        schema: it.schema || "public",
        colmns: fields,
        refTable: refTableName,
        refSchema: refSchema || "public",
        refColumns
      };
    })
  ).flat();
  return rels;
};

// src/sqlite.ts
function assertSQLiteTable(value) {
  if (!(0, import_drizzle_orm2.is)(value, import_sqlite_core2.SQLiteTable)) {
    throw new Error();
  }
}
var columnMapper = (column) => {
  if ((0, import_drizzle_orm2.is)(column, import_sqlite_core2.SQLiteTimestamp)) {
    return (input) => {
      if (input === void 0 || input === null)
        return null;
      return new Date(input);
    };
  }
  if ((0, import_drizzle_orm2.is)(column, import_sqlite_core2.SQLiteInteger)) {
    return (input) => {
      if (input === void 0 || input === null)
        return null;
      return Number(input);
    };
  }
  return (input) => input;
};
var typeForTable = (column) => {
  if ((0, import_drizzle_orm2.is)(column, import_sqlite_core2.SQLiteBoolean)) {
    return "boolean";
  }
  if ((0, import_drizzle_orm2.is)(column, import_sqlite_core2.SQLiteInteger)) {
    return "number";
  }
  if ((0, import_drizzle_orm2.is)(column, import_sqlite_core2.SQLiteTimestamp)) {
    return "date";
  }
  if ((0, import_drizzle_orm2.is)(column, import_sqlite_core2.SQLiteBlobJson) || (0, import_drizzle_orm2.is)(column, import_sqlite_core2.SQLiteTextJson)) {
    return "json";
  }
  if ((0, import_drizzle_orm2.is)(column, import_sqlite_core2.SQLiteBlobBuffer)) {
    return "base64";
  }
  return "string";
};
var selectFn = (db, tablesMap) => async (params) => {
  const table = tablesMap[params.table];
  const config = (0, import_sqlite_core2.getTableConfig)(table);
  const hasPartial = (params.columns && params.columns.length > 0) ?? false;
  const columns = (config.columns || []).reduce((acc, it) => {
    acc[it.name] = it;
    return acc;
  }, {});
  const partialSelect = (config.columns || []).reduce((acc, it) => {
    if (params.columns?.includes(it.name)) {
      acc[it.name] = it;
    }
    return acc;
  }, {});
  const orderByColumn = params.orderBy ? columns[params.orderBy.column] : void 0;
  const orderByExpr = orderByColumn ? params.orderBy.type === "ASC" ? [(0, import_drizzle_orm2.asc)(orderByColumn)] : [(0, import_drizzle_orm2.desc)(orderByColumn)] : [];
  const q = hasPartial ? db.select(partialSelect) : db.select();
  return await q.from(table).where(params.where ? filtersToSQL(params.where) : void 0).orderBy(...orderByExpr).limit(params.limit).offset(params.offset);
};
var insertFn = (db, tablesMap, tableToColumnNames) => (params) => {
  const table = tablesMap[params.table];
  const columnNamesMap = tableToColumnNames[params.table];
  const data = convertToTsColumns(params.data, columnNamesMap);
  return db.insert(table).values(data).run();
};
var dropTableFn = (db, tablesMap) => async (params) => {
  const { table } = params;
  const sqliteTable = tablesMap[table];
  if (!sqliteTable) {
    throw new Error(`Table ${params.table} not found`);
  }
  return await db.run(import_drizzle_orm2.sql`DROP TABLE IF EXISTS ${sqliteTable}`);
};
var deleteFn = (db, tablesMap) => (params) => {
  const table = tablesMap[params.table];
  return db.delete(table).where(filtersToSQL(params.where)).run();
};
var updateFn = (db, tablesMap, tableToColumnNames) => (params) => {
  const table = tablesMap[params.table];
  const columnNamesMap = tableToColumnNames[params.table];
  const data = convertToTsColumns(params.data, columnNamesMap);
  return db.update(table).set(data).where(filtersToSQL(params.where)).run();
};
var sqliteQueryEngine = async (setup) => {
  const { db } = setup;
  const schemaToTables = Object.fromEntries(
    Object.entries(setup.schema).map(([key, val]) => {
      const mapped = Object.values(val).reduce((acc, it) => {
        if ((0, import_drizzle_orm2.is)(it, import_sqlite_core2.SQLiteTable)) {
          const config = (0, import_sqlite_core2.getTableConfig)(it);
          acc[config.name] = it;
        }
        return acc;
      }, {});
      return [key, mapped];
    })
  );
  const schmaToTablesToColumnNames = Object.fromEntries(
    Object.entries(setup.schema).map(([key, val]) => {
      const mapped = Object.values(val).reduce(
        (acc, it) => {
          if ((0, import_drizzle_orm2.is)(it, import_sqlite_core2.SQLiteTable)) {
            const config = (0, import_sqlite_core2.getTableConfig)(it);
            const columnNamesMap = Object.fromEntries(
              Object.entries((0, import_drizzle_orm2.getTableColumns)(it)).map((col) => [
                col[1].name,
                {
                  name: col[0],
                  mapper: columnMapper(col[1])
                }
              ])
            );
            acc[config.name] = columnNamesMap;
          }
          return acc;
        },
        {}
      );
      return [key, mapped];
    })
  );
  const tablesFn = async (schema, options) => {
    const tablesConfig = setup.schema[schema];
    const perTablePromises = Object.values(tablesConfig).filter((it) => {
      return (0, import_drizzle_orm2.is)(it, import_sqlite_core2.SQLiteTable);
    }).map(async (it) => {
      assertSQLiteTable(it);
      const config = (0, import_sqlite_core2.getTableConfig)(it);
      const primaryKeys = config.primaryKeys.map((it2) => it2.columns.map((column) => column.name)).concat(config.columns.map((it2) => it2.primary ? it2.name : "")).filter(Boolean).flat();
      const tableName = config.name;
      const columns = config.columns.map((it2) => {
        return {
          name: it2.name,
          type: typeForTable(it2),
          _type: it2.getSQLType()
        };
      });
      let count = void 0;
      if (!options?.withoutCount) {
        const table = schemaToTables[schema][tableName];
        const result = await setup.db.select({
          count: import_drizzle_orm2.sql`count(*)`
        }).from(table).all();
        count = result[0].count;
      }
      return {
        name: tableName,
        columns,
        count,
        primaryKeys
      };
    });
    return Promise.all(perTablePromises);
  };
  const relationalSchema = {
    ...Object.fromEntries(
      Object.entries(setup.schema).map(([key, val]) => {
        const mappedTableEntries = Object.entries(val).map((tableEntry) => {
          return [`__${key}__.${tableEntry[0]}`, tableEntry[1]];
        });
        return mappedTableEntries;
      }).flat()
    ),
    ...setup.relations
  };
  const relationsConfig = (0, import_drizzle_orm2.extractTablesRelationalConfig)(
    relationalSchema,
    import_drizzle_orm2.createTableRelationsHelpers
  );
  return {
    dialect: "sqlite",
    proxy: setup.proxy,
    raw: (query) => {
      return Promise.resolve(db.all(import_drizzle_orm2.sql.raw(query)));
    },
    select: (schema) => selectFn(db, schemaToTables[schema]),
    insert: (schema) => insertFn(db, schemaToTables[schema], schmaToTablesToColumnNames[schema]),
    update: (schema) => updateFn(db, schemaToTables[schema], schmaToTablesToColumnNames[schema]),
    delete: (schema) => deleteFn(db, schemaToTables[schema]),
    dropTable: (schema) => dropTableFn(db, schemaToTables[schema]),
    truncate: (_) => () => {
      throw new Error("Truncate is not available in SQLite");
    },
    tables: tablesFn,
    schemas: Object.keys(setup.schema),
    relations: extractRelations(relationsConfig),
    ts: setup.ts
  };
};

// src/pg.ts
var import_pg_core2 = require("drizzle-orm/pg-core");
var import_drizzle_orm3 = require("drizzle-orm");
function assertPgTable(value) {
  if (!(0, import_drizzle_orm3.is)(value, import_pg_core2.PgTable)) {
    throw new Error();
  }
}
var columnMapper2 = (column) => {
  if ((0, import_drizzle_orm3.is)(column, import_pg_core2.PgTimestamp) || (0, import_drizzle_orm3.is)(column, import_pg_core2.PgDate)) {
    return (input) => {
      if (input === void 0 || input === null)
        return null;
      return new Date(input);
    };
  }
  if ((0, import_drizzle_orm3.is)(column, import_pg_core2.PgInteger) || (0, import_drizzle_orm3.is)(column, import_pg_core2.PgSmallInt) || (0, import_drizzle_orm3.is)(column, import_pg_core2.PgSerial) || (0, import_drizzle_orm3.is)(column, import_pg_core2.PgSmallSerial) || (0, import_drizzle_orm3.is)(column, import_pg_core2.PgDoublePrecision) || (0, import_drizzle_orm3.is)(column, import_pg_core2.PgReal)) {
    return (input) => {
      if (input === void 0 || input === null)
        return null;
      return Number(input);
    };
  }
  if ((0, import_drizzle_orm3.is)(column, import_pg_core2.PgBigInt53) || (0, import_drizzle_orm3.is)(column, import_pg_core2.PgBigSerial53)) {
    return (input) => Number(input);
  }
  if ((0, import_drizzle_orm3.is)(column, import_pg_core2.PgBigInt64) || (0, import_drizzle_orm3.is)(column, import_pg_core2.PgBigSerial64)) {
    return (input) => BigInt(input);
  }
  return (input) => input;
};
var typeForTable2 = (column) => {
  if ((0, import_drizzle_orm3.is)(column, import_pg_core2.PgBoolean)) {
    return "boolean";
  }
  if ((0, import_drizzle_orm3.is)(column, import_pg_core2.PgInteger) || (0, import_drizzle_orm3.is)(column, import_pg_core2.PgBigInt53) || (0, import_drizzle_orm3.is)(column, import_pg_core2.PgBigSerial53) || (0, import_drizzle_orm3.is)(column, import_pg_core2.PgReal) || (0, import_drizzle_orm3.is)(column, import_pg_core2.PgSerial) || (0, import_drizzle_orm3.is)(column, import_pg_core2.PgSmallInt) || (0, import_drizzle_orm3.is)(column, import_pg_core2.PgSmallSerial) || (0, import_drizzle_orm3.is)(column, import_pg_core2.PgDoublePrecision)) {
    return "number";
  }
  if ((0, import_drizzle_orm3.is)(column, import_pg_core2.PgTimestamp) || (0, import_drizzle_orm3.is)(column, import_pg_core2.PgTimestampString) || (0, import_drizzle_orm3.is)(column, import_pg_core2.PgDate) || (0, import_drizzle_orm3.is)(column, import_pg_core2.PgDateString)) {
    return "date";
  }
  if ((0, import_drizzle_orm3.is)(column, import_pg_core2.PgArray) || (0, import_drizzle_orm3.is)(column, import_pg_core2.PgJson) || (0, import_drizzle_orm3.is)(column, import_pg_core2.PgJsonb)) {
    return "json";
  }
  return "string";
};
var selectFn2 = (db, schema) => (params) => {
  const tablesMap = Object.values(schema).reduce((acc, it) => {
    if ((0, import_drizzle_orm3.is)(it, import_pg_core2.PgTable)) {
      const config2 = (0, import_pg_core2.getTableConfig)(it);
      acc[config2.name] = it;
    }
    return acc;
  }, {});
  const table = tablesMap[params.table];
  const config = (0, import_pg_core2.getTableConfig)(table);
  const hasPartial = (params.columns && params.columns.length > 0) ?? false;
  const columns = (config.columns || []).reduce(
    (acc, it) => {
      acc[it.name] = it;
      return acc;
    },
    {}
  );
  const partialSelect = (config.columns || []).reduce((acc, it) => {
    if (params.columns?.includes(it.name)) {
      acc[it.name] = it;
    }
    return acc;
  }, {});
  const orderByColumn = params.orderBy ? columns[params.orderBy.column] : void 0;
  const orderByExpr = orderByColumn ? params.orderBy.type === "ASC" ? [(0, import_drizzle_orm3.asc)(orderByColumn)] : [(0, import_drizzle_orm3.desc)(orderByColumn)] : [];
  const q = hasPartial ? db.select(partialSelect) : db.select();
  return q.from(table).where(params.where ? filtersToSQL(params.where) : void 0).orderBy(...orderByExpr).limit(params.limit).offset(params.offset).execute();
};
var dropTableFn2 = (db, tablesMap) => (params) => {
  const { isCascade, table } = params;
  const pgTable = tablesMap[table];
  if (!pgTable) {
    throw new Error(`Table ${table} not found`);
  }
  if (isCascade) {
    return db.execute(import_drizzle_orm3.sql`DROP TABLE IF EXISTS ${pgTable} CASCADE`);
  }
  return db.execute(import_drizzle_orm3.sql`DROP TABLE IF EXISTS ${pgTable}`);
};
var truncateTableFn = (db, tablesMap) => (params) => {
  const { isCascade, table } = params;
  const pgTable = tablesMap[table];
  if (!pgTable) {
    throw new Error(`Table ${table} not found`);
  }
  if (isCascade) {
    return db.execute(import_drizzle_orm3.sql`TRUNCATE TABLE ${pgTable} CASCADE`);
  }
  return db.execute(import_drizzle_orm3.sql`TRUNCATE TABLE ${pgTable}`);
};
var deleteFn2 = (db, tablesMap) => (params) => {
  const table = tablesMap[params.table];
  return db.delete(table).where(filtersToSQL(params.where)).execute();
};
var insertFn2 = (db, tablesMap, tableToColumnNames) => (params) => {
  const table = tablesMap[params.table];
  const columnNamesMap = tableToColumnNames[params.table];
  const data = convertToTsColumns(params.data, columnNamesMap);
  return db.insert(table).values(data).execute();
};
var updateFn2 = (db, tablesMap, tableToColumnNames) => (params) => {
  const table = tablesMap[params.table];
  const columnNamesMap = tableToColumnNames[params.table];
  const data = convertToTsColumns(params.data, columnNamesMap);
  return db.update(table).set(data).where(filtersToSQL(params.where)).execute();
};
var pgQueryEngine = async (setup) => {
  const { db } = setup;
  const schemaToTables = Object.fromEntries(
    Object.entries(setup.schema).map(([key, val]) => {
      const mapped = Object.values(val).reduce((acc, it) => {
        if ((0, import_drizzle_orm3.is)(it, import_pg_core2.PgTable)) {
          const config = (0, import_pg_core2.getTableConfig)(it);
          acc[config.name] = it;
        }
        return acc;
      }, {});
      return [key, mapped];
    })
  );
  const schmaToTablesToColumnNames = Object.fromEntries(
    Object.entries(setup.schema).map(([key, val]) => {
      const mapped = Object.values(val).reduce(
        (acc, it) => {
          if ((0, import_drizzle_orm3.is)(it, import_pg_core2.PgTable)) {
            const config = (0, import_pg_core2.getTableConfig)(it);
            const columnNamesMap = Object.fromEntries(
              Object.entries((0, import_drizzle_orm3.getTableColumns)(it)).map((col) => [
                col[1].name,
                {
                  name: col[0],
                  mapper: columnMapper2(col[1])
                }
              ])
            );
            acc[config.name] = columnNamesMap;
          }
          return acc;
        },
        {}
      );
      return [key, mapped];
    })
  );
  const tables = async (schema, options) => {
    const tablesConfig = setup.schema[schema];
    const perTablePromises = Object.values(tablesConfig).filter((it) => {
      return (0, import_drizzle_orm3.is)(it, import_pg_core2.PgTable);
    }).map(async (it) => {
      assertPgTable(it);
      const config = (0, import_pg_core2.getTableConfig)(it);
      const primaryKeys = config.primaryKeys.map((it2) => it2.columns.map((column) => column.name)).concat(config.columns.map((it2) => it2.primary ? it2.name : "")).filter(Boolean).flat();
      const tableName = config.name;
      const columns = config.columns.map((it2) => ({
        name: it2.name,
        type: typeForTable2(it2),
        _type: it2.getSQLType()
      }));
      let count = void 0;
      if (!options?.withoutCount) {
        const table = schemaToTables[schema][tableName];
        const result = await setup.db.select({
          count: import_drizzle_orm3.sql`count(*)`.mapWith((it2) => Number(it2))
        }).from(table).execute();
        count = result[0].count;
      }
      return {
        name: tableName,
        columns,
        count,
        primaryKeys
      };
    });
    return Promise.all(perTablePromises);
  };
  const relationalSchema = {
    ...Object.fromEntries(
      Object.entries(setup.schema).map(([key, val]) => {
        const mappedTableEntries = Object.entries(val).map((tableEntry) => {
          return [`__${key}__.${tableEntry[0]}`, tableEntry[1]];
        });
        return mappedTableEntries;
      }).flat()
    ),
    ...setup.relations
  };
  const relationsConfig = (0, import_drizzle_orm3.extractTablesRelationalConfig)(
    relationalSchema,
    import_drizzle_orm3.createTableRelationsHelpers
  );
  return {
    dialect: "pg",
    proxy: setup.proxy,
    raw: setup.raw,
    select: (schema) => selectFn2(db, schemaToTables[schema]),
    delete: (schema) => deleteFn2(db, schemaToTables[schema]),
    insert: (schema) => insertFn2(db, schemaToTables[schema], schmaToTablesToColumnNames[schema]),
    update: (schema) => updateFn2(db, schemaToTables[schema], schmaToTablesToColumnNames[schema]),
    dropTable: (schema) => dropTableFn2(db, schemaToTables[schema]),
    truncate: (schema) => truncateTableFn(db, schemaToTables[schema]),
    tables,
    schemas: Object.keys(setup.schema),
    relations: extractRelations(relationsConfig),
    ts: setup.ts
  };
};

// src/mysql.ts
var import_drizzle_orm4 = require("drizzle-orm");
var import_mysql_core2 = require("drizzle-orm/mysql-core");
var typeForTable3 = (column) => {
  if ((0, import_drizzle_orm4.is)(column, import_mysql_core2.MySqlBoolean)) {
    return "boolean";
  }
  if ((0, import_drizzle_orm4.is)(column, import_mysql_core2.MySqlInt) || (0, import_drizzle_orm4.is)(column, import_mysql_core2.MySqlTinyInt) || (0, import_drizzle_orm4.is)(column, import_mysql_core2.MySqlSmallInt) || (0, import_drizzle_orm4.is)(column, import_mysql_core2.MySqlMediumInt) || (0, import_drizzle_orm4.is)(column, import_mysql_core2.MySqlFloat) || (0, import_drizzle_orm4.is)(column, import_mysql_core2.MySqlBigInt53) || (0, import_drizzle_orm4.is)(column, import_mysql_core2.MySqlDouble)) {
    return "number";
  }
  if ((0, import_drizzle_orm4.is)(column, import_mysql_core2.MySqlTimestamp) || (0, import_drizzle_orm4.is)(column, import_mysql_core2.MySqlTimestampString) || (0, import_drizzle_orm4.is)(column, import_mysql_core2.MySqlDate) || (0, import_drizzle_orm4.is)(column, import_mysql_core2.MySqlDateString)) {
    return "date";
  }
  if ((0, import_drizzle_orm4.is)(column, import_mysql_core2.MySqlJson)) {
    return "json";
  }
  return "string";
};
function assertMysqlTable(value) {
  if (!(0, import_drizzle_orm4.is)(value, import_mysql_core2.MySqlTable)) {
    throw new Error();
  }
}
var columnMapper3 = (column) => {
  if ((0, import_drizzle_orm4.is)(column, import_mysql_core2.MySqlTimestamp) || (0, import_drizzle_orm4.is)(column, import_mysql_core2.MySqlDate)) {
    return (input) => {
      if (input === void 0 || input === null)
        return null;
      return new Date(input);
    };
  }
  if ((0, import_drizzle_orm4.is)(column, import_mysql_core2.MySqlInt) || (0, import_drizzle_orm4.is)(column, import_mysql_core2.MySqlTinyInt) || (0, import_drizzle_orm4.is)(column, import_mysql_core2.MySqlSmallInt) || (0, import_drizzle_orm4.is)(column, import_mysql_core2.MySqlMediumInt) || (0, import_drizzle_orm4.is)(column, import_mysql_core2.MySqlFloat) || (0, import_drizzle_orm4.is)(column, import_mysql_core2.MySqlDouble)) {
    return (input) => {
      if (input === void 0 || input === null)
        return null;
      return Number(input);
    };
  }
  if ((0, import_drizzle_orm4.is)(column, import_mysql_core2.MySqlBigInt53)) {
    return (input) => Number(input);
  }
  if ((0, import_drizzle_orm4.is)(column, import_mysql_core2.MySqlBigInt64)) {
    return (input) => BigInt(input);
  }
  return (input) => input;
};
var selectFn3 = (db, tablesMap) => (params) => {
  const table = tablesMap[params.table];
  const config = (0, import_mysql_core2.getTableConfig)(table);
  const hasPartial = (params.columns && params.columns.length > 0) ?? false;
  const columns = (config.columns || []).reduce((acc, it) => {
    acc[it.name] = it;
    return acc;
  }, {});
  const partialSelect = (config.columns || []).reduce((acc, it) => {
    if (params.columns?.includes(it.name)) {
      acc[it.name] = it;
    }
    return acc;
  }, {});
  const orderByColumn = params.orderBy ? columns[params.orderBy.column] : void 0;
  const orderByExpr = orderByColumn ? params.orderBy.type === "ASC" ? [(0, import_drizzle_orm4.asc)(orderByColumn)] : [(0, import_drizzle_orm4.desc)(orderByColumn)] : [];
  const q = hasPartial ? db.select(partialSelect) : db.select();
  return q.from(table).where(params.where ? filtersToSQL(params.where) : void 0).orderBy(...orderByExpr).limit(params.limit).offset(params.offset).execute();
};
var dropTableFn3 = (db, tablesMap) => (params) => {
  const { isCascade, table } = params;
  const mysqlTable = tablesMap[table];
  if (!mysqlTable) {
    throw new Error(`Table ${table} not found`);
  }
  if (isCascade) {
    return db.execute(import_drizzle_orm4.sql`DROP TABLE IF EXISTS ${mysqlTable} CASCADE`);
  }
  return db.execute(import_drizzle_orm4.sql`DROP TABLE IF EXISTS ${mysqlTable}`);
};
var truncateFn = (db, tablesMap) => (params) => {
  const { table } = params;
  const mysqlTable = tablesMap[table];
  if (!mysqlTable) {
    throw new Error(`Table ${table} not found`);
  }
  return db.execute(import_drizzle_orm4.sql`TRUNCATE TABLE ${mysqlTable}`);
};
var deleteFn3 = (db, tablesMap) => (params) => {
  const table = tablesMap[params.table];
  return db.delete(table).where(filtersToSQL(params.where)).execute();
};
var insertFn3 = (db, tablesMap, tableToColumnNames) => (params) => {
  const table = tablesMap[params.table];
  const columnNamesMap = tableToColumnNames[params.table];
  const data = convertToTsColumns(params.data, columnNamesMap);
  return db.insert(table).values(data).execute();
};
var updateFn3 = (db, tablesMap, tableToColumnNames) => (params) => {
  const table = tablesMap[params.table];
  const columnNamesMap = tableToColumnNames[params.table];
  const data = convertToTsColumns(params.data, columnNamesMap);
  return db.update(table).set(data).where(filtersToSQL(params.where)).execute();
};
var mysqlQueryEngine = async (setup) => {
  const { db } = setup;
  const schemaToTables = Object.fromEntries(
    Object.entries(setup.schema).map(([key, val]) => {
      const mapped = Object.values(val).reduce((acc, it) => {
        if ((0, import_drizzle_orm4.is)(it, import_mysql_core2.MySqlTable)) {
          const config = (0, import_mysql_core2.getTableConfig)(it);
          acc[config.name] = it;
        }
        return acc;
      }, {});
      return [key, mapped];
    })
  );
  const schmaToTablesToColumnNames = Object.fromEntries(
    Object.entries(setup.schema).map(([key, val]) => {
      const mapped = Object.values(val).reduce(
        (acc, it) => {
          if ((0, import_drizzle_orm4.is)(it, import_mysql_core2.MySqlTable)) {
            const config = (0, import_mysql_core2.getTableConfig)(it);
            const columnNamesMap = Object.fromEntries(
              Object.entries((0, import_drizzle_orm4.getTableColumns)(it)).map((col) => [
                col[1].name,
                {
                  name: col[0],
                  mapper: columnMapper3(col[1])
                }
              ])
            );
            acc[config.name] = columnNamesMap;
          }
          return acc;
        },
        {}
      );
      return [key, mapped];
    })
  );
  const tables = async (schema, options) => {
    const tablesConfig = setup.schema[schema];
    const perTablePromises = Object.values(tablesConfig).filter((it) => {
      return (0, import_drizzle_orm4.is)(it, import_mysql_core2.MySqlTable);
    }).map(async (it) => {
      assertMysqlTable(it);
      const config = (0, import_mysql_core2.getTableConfig)(it);
      const primaryKeys = config.primaryKeys.map((it2) => it2.columns.map((column) => column.name)).concat(config.columns.map((it2) => it2.primary ? it2.name : "")).filter(Boolean).flat();
      const tableName = config.name;
      const columns = config.columns.map((it2) => ({
        name: it2.name,
        type: typeForTable3(it2),
        _type: it2.getSQLType()
      }));
      let count = void 0;
      if (!options?.withoutCount) {
        const table = schemaToTables[schema][tableName];
        const result = await setup.db.select({
          count: import_drizzle_orm4.sql`count(*)`
        }).from(table).execute();
        count = result[0].count;
      }
      return {
        name: tableName,
        columns,
        count,
        primaryKeys
      };
    });
    return Promise.all(perTablePromises);
  };
  const relationalSchema = {
    ...Object.fromEntries(
      Object.entries(setup.schema).map(([key, val]) => {
        const mappedTableEntries = Object.entries(val).map((tableEntry) => {
          return [`__${key}__.${tableEntry[0]}`, tableEntry[1]];
        });
        return mappedTableEntries;
      }).flat()
    ),
    ...setup.relations
  };
  const relationsConfig = (0, import_drizzle_orm4.extractTablesRelationalConfig)(
    relationalSchema,
    import_drizzle_orm4.createTableRelationsHelpers
  );
  return {
    dialect: "mysql",
    proxy: setup.proxy,
    raw: setup.raw,
    select: (schema) => selectFn3(db, schemaToTables[schema]),
    delete: (schema) => deleteFn3(db, schemaToTables[schema]),
    insert: (schema) => insertFn3(db, schemaToTables[schema], schmaToTablesToColumnNames[schema]),
    update: (schema) => updateFn3(db, schemaToTables[schema], schmaToTablesToColumnNames[schema]),
    dropTable: (schema) => dropTableFn3(db, schemaToTables[schema]),
    truncate: (schema) => truncateFn(db, schemaToTables[schema]),
    tables,
    schemas: Object.keys(setup.schema),
    relations: extractRelations(relationsConfig),
    ts: setup.ts
  };
};

// src/index.ts
var queryEngineForSetup = async (setup) => {
  if (setup.dialect === "sqlite")
    return sqliteQueryEngine(setup);
  if (setup.dialect === "pg")
    return pgQueryEngine(setup);
  if (setup.dialect === "mysql")
    return mysqlQueryEngine(setup);
  throw new Error("unknown setup");
};
