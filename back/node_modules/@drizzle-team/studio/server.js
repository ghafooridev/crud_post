"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// node_modules/.pnpm/hono@3.8.1/node_modules/hono/dist/cjs/utils/url.js
var require_url = __commonJS({
  "node_modules/.pnpm/hono@3.8.1/node_modules/hono/dist/cjs/utils/url.js"(exports, module2) {
    "use strict";
    var __defProp2 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp2(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps2 = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames2(from))
          if (!__hasOwnProp2.call(to, key) && key !== except)
            __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod) => __copyProps2(__defProp2({}, "__esModule", { value: true }), mod);
    var url_exports = {};
    __export2(url_exports, {
      checkOptionalParameter: () => checkOptionalParameter2,
      decodeURIComponent_: () => decodeURIComponent_2,
      getPath: () => getPath2,
      getPathNoStrict: () => getPathNoStrict2,
      getPattern: () => getPattern2,
      getQueryParam: () => getQueryParam2,
      getQueryParams: () => getQueryParams2,
      getQueryStrings: () => getQueryStrings2,
      mergePath: () => mergePath2,
      splitPath: () => splitPath2,
      splitRoutingPath: () => splitRoutingPath2
    });
    module2.exports = __toCommonJS2(url_exports);
    var splitPath2 = (path) => {
      const paths = path.split("/");
      if (paths[0] === "") {
        paths.shift();
      }
      return paths;
    };
    var splitRoutingPath2 = (path) => {
      const groups = [];
      for (let i = 0; ; ) {
        let replaced = false;
        path = path.replace(/\{[^}]+\}/g, (m) => {
          const mark = `@\\${i}`;
          groups[i] = [mark, m];
          i++;
          replaced = true;
          return mark;
        });
        if (!replaced) {
          break;
        }
      }
      const paths = path.split("/");
      if (paths[0] === "") {
        paths.shift();
      }
      for (let i = groups.length - 1; i >= 0; i--) {
        const [mark] = groups[i];
        for (let j = paths.length - 1; j >= 0; j--) {
          if (paths[j].indexOf(mark) !== -1) {
            paths[j] = paths[j].replace(mark, groups[i][1]);
            break;
          }
        }
      }
      return paths;
    };
    var patternCache2 = {};
    var getPattern2 = (label) => {
      if (label === "*") {
        return "*";
      }
      const match = label.match(/^\:([^\{\}]+)(?:\{(.+)\})?$/);
      if (match) {
        if (!patternCache2[label]) {
          if (match[2]) {
            patternCache2[label] = [label, match[1], new RegExp("^" + match[2] + "$")];
          } else {
            patternCache2[label] = [label, match[1], true];
          }
        }
        return patternCache2[label];
      }
      return null;
    };
    var getPath2 = (request) => {
      const match = request.url.match(/^https?:\/\/[^/]+(\/[^?]*)/);
      return match ? match[1] : "";
    };
    var getQueryStrings2 = (url) => {
      const queryIndex = url.indexOf("?", 8);
      return queryIndex === -1 ? "" : "?" + url.slice(queryIndex + 1);
    };
    var getPathNoStrict2 = (request) => {
      const result = getPath2(request);
      return result.length > 1 && result[result.length - 1] === "/" ? result.slice(0, -1) : result;
    };
    var mergePath2 = (...paths) => {
      let p = "";
      let endsWithSlash = false;
      for (let path of paths) {
        if (p[p.length - 1] === "/") {
          p = p.slice(0, -1);
          endsWithSlash = true;
        }
        if (path[0] !== "/") {
          path = `/${path}`;
        }
        if (path === "/" && endsWithSlash) {
          p = `${p}/`;
        } else if (path !== "/") {
          p = `${p}${path}`;
        }
        if (path === "/" && p === "") {
          p = "/";
        }
      }
      return p;
    };
    var checkOptionalParameter2 = (path) => {
      const match = path.match(/^(.+|)(\/\:[^\/]+)\?$/);
      if (!match)
        return null;
      const base = match[1];
      const optional2 = base + match[2];
      return [base === "" ? "/" : base.replace(/\/$/, ""), optional2];
    };
    var _decodeURI2 = (value) => {
      if (!/[%+]/.test(value)) {
        return value;
      }
      if (value.indexOf("+") !== -1) {
        value = value.replace(/\+/g, " ");
      }
      return /%/.test(value) ? decodeURIComponent_2(value) : value;
    };
    var _getQueryParam2 = (url, key, multiple) => {
      let encoded;
      if (!multiple && key && !/[%+]/.test(key)) {
        let keyIndex2 = url.indexOf(`?${key}`, 8);
        if (keyIndex2 === -1) {
          keyIndex2 = url.indexOf(`&${key}`, 8);
        }
        while (keyIndex2 !== -1) {
          const trailingKeyCode = url.charCodeAt(keyIndex2 + key.length + 1);
          if (trailingKeyCode === 61) {
            const valueIndex = keyIndex2 + key.length + 2;
            const endIndex = url.indexOf("&", valueIndex);
            return _decodeURI2(url.slice(valueIndex, endIndex === -1 ? void 0 : endIndex));
          } else if (trailingKeyCode == 38 || isNaN(trailingKeyCode)) {
            return "";
          }
          keyIndex2 = url.indexOf(`&${key}`, keyIndex2 + 1);
        }
        encoded = /[%+]/.test(url);
        if (!encoded) {
          return void 0;
        }
      }
      const results = {};
      encoded ?? (encoded = /[%+]/.test(url));
      let keyIndex = url.indexOf("?", 8);
      while (keyIndex !== -1) {
        const nextKeyIndex = url.indexOf("&", keyIndex + 1);
        let valueIndex = url.indexOf("=", keyIndex);
        if (valueIndex > nextKeyIndex && nextKeyIndex !== -1) {
          valueIndex = -1;
        }
        let name = url.slice(
          keyIndex + 1,
          valueIndex === -1 ? nextKeyIndex === -1 ? void 0 : nextKeyIndex : valueIndex
        );
        if (encoded) {
          name = _decodeURI2(name);
        }
        keyIndex = nextKeyIndex;
        if (name === "") {
          continue;
        }
        let value;
        if (valueIndex === -1) {
          value = "";
        } else {
          value = url.slice(valueIndex + 1, nextKeyIndex === -1 ? void 0 : nextKeyIndex);
          if (encoded) {
            value = _decodeURI2(value);
          }
        }
        if (multiple) {
          ;
          (results[name] ?? (results[name] = [])).push(value);
        } else {
          results[name] ?? (results[name] = value);
        }
      }
      return key ? results[key] : results;
    };
    var getQueryParam2 = _getQueryParam2;
    var getQueryParams2 = (url, key) => {
      return _getQueryParam2(url, key, true);
    };
    var decodeURIComponent_2 = decodeURIComponent;
  }
});

// node_modules/.pnpm/hono@3.8.1/node_modules/hono/dist/cjs/utils/cookie.js
var require_cookie = __commonJS({
  "node_modules/.pnpm/hono@3.8.1/node_modules/hono/dist/cjs/utils/cookie.js"(exports, module2) {
    "use strict";
    var __defProp2 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp2(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps2 = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames2(from))
          if (!__hasOwnProp2.call(to, key) && key !== except)
            __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod) => __copyProps2(__defProp2({}, "__esModule", { value: true }), mod);
    var cookie_exports = {};
    __export2(cookie_exports, {
      parse: () => parse3,
      parseSigned: () => parseSigned,
      serialize: () => serialize3,
      serializeSigned: () => serializeSigned
    });
    module2.exports = __toCommonJS2(cookie_exports);
    var import_url7 = require_url();
    var algorithm = { name: "HMAC", hash: "SHA-256" };
    var getCryptoKey = async (secret) => {
      const secretBuf = typeof secret === "string" ? new TextEncoder().encode(secret) : secret;
      return await crypto.subtle.importKey("raw", secretBuf, algorithm, false, ["sign", "verify"]);
    };
    var makeSignature = async (value, secret) => {
      const key = await getCryptoKey(secret);
      const signature = await crypto.subtle.sign(algorithm.name, key, new TextEncoder().encode(value));
      return btoa(String.fromCharCode(...new Uint8Array(signature)));
    };
    var verifySignature = async (base64Signature, value, secret) => {
      try {
        const signatureBinStr = atob(base64Signature);
        const signature = new Uint8Array(signatureBinStr.length);
        for (let i = 0; i < signatureBinStr.length; i++)
          signature[i] = signatureBinStr.charCodeAt(i);
        return await crypto.subtle.verify(algorithm, secret, signature, new TextEncoder().encode(value));
      } catch (e) {
        return false;
      }
    };
    var validCookieNameRegEx2 = /^[\w!#$%&'*.^`|~+-]+$/;
    var validCookieValueRegEx2 = /^[ !#-:<-[\]-~]*$/;
    var parse3 = (cookie, name) => {
      const pairs = cookie.trim().split(";");
      return pairs.reduce((parsedCookie, pairStr) => {
        pairStr = pairStr.trim();
        const valueStartPos = pairStr.indexOf("=");
        if (valueStartPos === -1)
          return parsedCookie;
        const cookieName = pairStr.substring(0, valueStartPos).trim();
        if (name && name !== cookieName || !validCookieNameRegEx2.test(cookieName))
          return parsedCookie;
        let cookieValue = pairStr.substring(valueStartPos + 1).trim();
        if (cookieValue.startsWith('"') && cookieValue.endsWith('"'))
          cookieValue = cookieValue.slice(1, -1);
        if (validCookieValueRegEx2.test(cookieValue))
          parsedCookie[cookieName] = (0, import_url7.decodeURIComponent_)(cookieValue);
        return parsedCookie;
      }, {});
    };
    var parseSigned = async (cookie, secret, name) => {
      const parsedCookie = {};
      const secretKey = await getCryptoKey(secret);
      for (const [key, value] of Object.entries(parse3(cookie, name))) {
        const signatureStartPos = value.lastIndexOf(".");
        if (signatureStartPos < 1)
          continue;
        const signedValue = value.substring(0, signatureStartPos);
        const signature = value.substring(signatureStartPos + 1);
        if (signature.length !== 44 || !signature.endsWith("="))
          continue;
        const isVerified = await verifySignature(signature, signedValue, secretKey);
        parsedCookie[key] = isVerified ? signedValue : false;
      }
      return parsedCookie;
    };
    var _serialize2 = (name, value, opt = {}) => {
      let cookie = `${name}=${value}`;
      if (opt && typeof opt.maxAge === "number" && opt.maxAge >= 0) {
        cookie += `; Max-Age=${Math.floor(opt.maxAge)}`;
      }
      if (opt.domain) {
        cookie += `; Domain=${opt.domain}`;
      }
      if (opt.path) {
        cookie += `; Path=${opt.path}`;
      }
      if (opt.expires) {
        cookie += `; Expires=${opt.expires.toUTCString()}`;
      }
      if (opt.httpOnly) {
        cookie += "; HttpOnly";
      }
      if (opt.secure) {
        cookie += "; Secure";
      }
      if (opt.sameSite) {
        cookie += `; SameSite=${opt.sameSite}`;
      }
      if (opt.partitioned) {
        cookie += "; Partitioned";
      }
      return cookie;
    };
    var serialize3 = (name, value, opt = {}) => {
      value = encodeURIComponent(value);
      return _serialize2(name, value, opt);
    };
    var serializeSigned = async (name, value, secret, opt = {}) => {
      const signature = await makeSignature(value, secret);
      value = `${value}.${signature}`;
      value = encodeURIComponent(value);
      return _serialize2(name, value, opt);
    };
  }
});

// node_modules/.pnpm/hono@3.8.1/node_modules/hono/dist/cjs/helper/cookie/index.js
var require_cookie2 = __commonJS({
  "node_modules/.pnpm/hono@3.8.1/node_modules/hono/dist/cjs/helper/cookie/index.js"(exports, module2) {
    "use strict";
    var __defProp2 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp2(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps2 = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames2(from))
          if (!__hasOwnProp2.call(to, key) && key !== except)
            __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod) => __copyProps2(__defProp2({}, "__esModule", { value: true }), mod);
    var cookie_exports = {};
    __export2(cookie_exports, {
      deleteCookie: () => deleteCookie,
      getCookie: () => getCookie,
      getSignedCookie: () => getSignedCookie,
      setCookie: () => setCookie,
      setSignedCookie: () => setSignedCookie
    });
    module2.exports = __toCommonJS2(cookie_exports);
    var import_cookie3 = require_cookie();
    var getCookie = (c, key) => {
      const cookie = c.req.raw.headers.get("Cookie");
      if (typeof key === "string") {
        if (!cookie)
          return void 0;
        const obj2 = (0, import_cookie3.parse)(cookie, key);
        return obj2[key];
      }
      if (!cookie)
        return {};
      const obj = (0, import_cookie3.parse)(cookie);
      return obj;
    };
    var getSignedCookie = async (c, secret, key) => {
      const cookie = c.req.raw.headers.get("Cookie");
      if (typeof key === "string") {
        if (!cookie)
          return void 0;
        const obj2 = await (0, import_cookie3.parseSigned)(cookie, secret, key);
        return obj2[key];
      }
      if (!cookie)
        return {};
      const obj = await (0, import_cookie3.parseSigned)(cookie, secret);
      return obj;
    };
    var setCookie = (c, name, value, opt) => {
      const cookie = (0, import_cookie3.serialize)(name, value, opt);
      c.header("set-cookie", cookie, { append: true });
    };
    var setSignedCookie = async (c, name, value, secret, opt) => {
      const cookie = await (0, import_cookie3.serializeSigned)(name, value, secret, opt);
      c.header("set-cookie", cookie, { append: true });
    };
    var deleteCookie = (c, name, opt) => {
      setCookie(c, name, "", { ...opt, maxAge: 0 });
    };
  }
});

// node_modules/.pnpm/hono@3.8.1/node_modules/hono/dist/cjs/utils/crypto.js
var require_crypto = __commonJS({
  "node_modules/.pnpm/hono@3.8.1/node_modules/hono/dist/cjs/utils/crypto.js"(exports, module2) {
    "use strict";
    var __defProp2 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp2(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps2 = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames2(from))
          if (!__hasOwnProp2.call(to, key) && key !== except)
            __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod) => __copyProps2(__defProp2({}, "__esModule", { value: true }), mod);
    var crypto_exports = {};
    __export2(crypto_exports, {
      createHash: () => createHash,
      md5: () => md5,
      sha1: () => sha1,
      sha256: () => sha256
    });
    module2.exports = __toCommonJS2(crypto_exports);
    var sha256 = async (data) => {
      const algorithm = { name: "SHA-256", alias: "sha256" };
      const hash = await createHash(data, algorithm);
      return hash;
    };
    var sha1 = async (data) => {
      const algorithm = { name: "SHA-1", alias: "sha1" };
      const hash = await createHash(data, algorithm);
      return hash;
    };
    var md5 = async (data) => {
      const algorithm = { name: "MD5", alias: "md5" };
      const hash = await createHash(data, algorithm);
      return hash;
    };
    var createHash = async (data, algorithm) => {
      let sourceBuffer;
      if (data instanceof ReadableStream) {
        let body = "";
        const reader = data.getReader();
        await reader?.read().then(async (chuck) => {
          const value = await createHash(chuck.value || "", algorithm);
          body += value;
        });
        return body;
      }
      if (ArrayBuffer.isView(data) || data instanceof ArrayBuffer) {
        sourceBuffer = data;
      } else {
        if (typeof data === "object") {
          data = JSON.stringify(data);
        }
        sourceBuffer = new TextEncoder().encode(String(data));
      }
      if (crypto && crypto.subtle) {
        const buffer = await crypto.subtle.digest(
          {
            name: algorithm.name
          },
          sourceBuffer
        );
        const hash = Array.prototype.map.call(new Uint8Array(buffer), (x) => ("00" + x.toString(16)).slice(-2)).join("");
        return hash;
      }
      return null;
    };
  }
});

// node_modules/.pnpm/hono@3.8.1/node_modules/hono/dist/cjs/utils/buffer.js
var require_buffer = __commonJS({
  "node_modules/.pnpm/hono@3.8.1/node_modules/hono/dist/cjs/utils/buffer.js"(exports, module2) {
    "use strict";
    var __defProp2 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp2(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps2 = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames2(from))
          if (!__hasOwnProp2.call(to, key) && key !== except)
            __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod) => __copyProps2(__defProp2({}, "__esModule", { value: true }), mod);
    var buffer_exports = {};
    __export2(buffer_exports, {
      bufferToFormData: () => bufferToFormData,
      bufferToString: () => bufferToString,
      equal: () => equal,
      timingSafeEqual: () => timingSafeEqual
    });
    module2.exports = __toCommonJS2(buffer_exports);
    var import_crypto = require_crypto();
    var equal = (a, b) => {
      if (a === b) {
        return true;
      }
      if (a.byteLength !== b.byteLength) {
        return false;
      }
      const va = new DataView(a);
      const vb = new DataView(b);
      let i = va.byteLength;
      while (i--) {
        if (va.getUint8(i) !== vb.getUint8(i)) {
          return false;
        }
      }
      return true;
    };
    var timingSafeEqual = async (a, b, hashFunction) => {
      if (!hashFunction) {
        hashFunction = import_crypto.sha256;
      }
      const sa = await hashFunction(a);
      const sb = await hashFunction(b);
      if (!sa || !sb) {
        return false;
      }
      return sa === sb && a === b;
    };
    var bufferToString = (buffer) => {
      if (buffer instanceof ArrayBuffer) {
        const enc = new TextDecoder("utf-8");
        return enc.decode(buffer);
      }
      return buffer;
    };
    var bufferToFormData = (arrayBuffer, contentType) => {
      const response = new Response(arrayBuffer, {
        headers: {
          "Content-Type": contentType
        }
      });
      return response.formData();
    };
  }
});

// node_modules/.pnpm/hono@3.8.1/node_modules/hono/dist/cjs/validator/validator.js
var require_validator = __commonJS({
  "node_modules/.pnpm/hono@3.8.1/node_modules/hono/dist/cjs/validator/validator.js"(exports, module2) {
    "use strict";
    var __defProp2 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp2(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps2 = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames2(from))
          if (!__hasOwnProp2.call(to, key) && key !== except)
            __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod) => __copyProps2(__defProp2({}, "__esModule", { value: true }), mod);
    var validator_exports = {};
    __export2(validator_exports, {
      validator: () => validator2
    });
    module2.exports = __toCommonJS2(validator_exports);
    var import_cookie3 = require_cookie2();
    var import_buffer = require_buffer();
    var validator2 = (target, validationFunc) => {
      return async (c, next) => {
        let value = {};
        switch (target) {
          case "json":
            try {
              const contentType = c.req.header("Content-Type");
              if (!contentType || !contentType.startsWith("application/json")) {
                throw new Error(`Invalid HTTP header: Content-Type=${contentType}`);
              }
              const arrayBuffer = c.req.bodyCache.arrayBuffer ?? await c.req.raw.arrayBuffer();
              value = await new Response(arrayBuffer).json();
              c.req.bodyCache.json = value;
              c.req.bodyCache.arrayBuffer = arrayBuffer;
            } catch {
              console.error("Error: Malformed JSON in request body");
              return c.json(
                {
                  success: false,
                  message: "Malformed JSON in request body"
                },
                400
              );
            }
            break;
          case "form": {
            try {
              const contentType = c.req.header("Content-Type");
              if (contentType) {
                const arrayBuffer = c.req.bodyCache.arrayBuffer ?? await c.req.raw.arrayBuffer();
                const formData = await (0, import_buffer.bufferToFormData)(arrayBuffer, contentType);
                const form = {};
                formData.forEach((value2, key) => {
                  form[key] = value2;
                });
                value = form;
                c.req.bodyCache.formData = formData;
                c.req.bodyCache.arrayBuffer = arrayBuffer;
              }
            } catch (e) {
              let message = "Malformed FormData request.";
              message += e instanceof Error ? ` ${e.message}` : ` ${String(e)}`;
              return c.json(
                {
                  success: false,
                  message
                },
                400
              );
            }
            break;
          }
          case "query":
            value = Object.fromEntries(
              Object.entries(c.req.queries()).map(([k, v]) => {
                return v.length === 1 ? [k, v[0]] : [k, v];
              })
            );
            break;
          case "queries":
            value = c.req.queries();
            console.log("Warnings: Validate type `queries` is deprecated. Use `query` instead.");
            break;
          case "param":
            value = c.req.param();
            break;
          case "header":
            value = c.req.header();
            break;
          case "cookie":
            value = (0, import_cookie3.getCookie)(c);
            break;
        }
        const res = await validationFunc(value, c);
        if (res instanceof Response) {
          return res;
        }
        c.req.addValidatedData(target, res);
        await next();
      };
    };
  }
});

// node_modules/.pnpm/hono@3.8.1/node_modules/hono/dist/cjs/validator/index.js
var require_validator2 = __commonJS({
  "node_modules/.pnpm/hono@3.8.1/node_modules/hono/dist/cjs/validator/index.js"(exports, module2) {
    "use strict";
    var __defProp2 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp2(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps2 = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames2(from))
          if (!__hasOwnProp2.call(to, key) && key !== except)
            __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod) => __copyProps2(__defProp2({}, "__esModule", { value: true }), mod);
    var validator_exports = {};
    __export2(validator_exports, {
      validator: () => import_validator.validator
    });
    module2.exports = __toCommonJS2(validator_exports);
    var import_validator = require_validator();
  }
});

// node_modules/.pnpm/valibot@0.19.0/node_modules/valibot/dist/index.cjs
var require_dist = __commonJS({
  "node_modules/.pnpm/valibot@0.19.0/node_modules/valibot/dist/index.cjs"(exports, module2) {
    "use strict";
    var __defProp2 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp2(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps2 = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames2(from))
          if (!__hasOwnProp2.call(to, key) && key !== except)
            __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod) => __copyProps2(__defProp2({}, "__esModule", { value: true }), mod);
    var src_exports = {};
    __export2(src_exports, {
      BrandSymbol: () => BrandSymbol2,
      ValiError: () => ValiError,
      any: () => any2,
      anyAsync: () => anyAsync,
      array: () => array2,
      arrayAsync: () => arrayAsync,
      bigint: () => bigint,
      bigintAsync: () => bigintAsync,
      blob: () => blob,
      blobAsync: () => blobAsync,
      boolean: () => boolean2,
      booleanAsync: () => booleanAsync,
      brand: () => brand,
      bytes: () => bytes,
      coerce: () => coerce,
      coerceAsync: () => coerceAsync,
      cuid2: () => cuid2,
      custom: () => custom,
      customAsync: () => customAsync,
      date: () => date,
      dateAsync: () => dateAsync,
      email: () => email,
      emoji: () => emoji,
      endsWith: () => endsWith,
      enumType: () => enumType2,
      enumTypeAsync: () => enumTypeAsync,
      equal: () => equal,
      excludes: () => excludes,
      executePipe: () => executePipe2,
      executePipeAsync: () => executePipeAsync,
      fallback: () => fallback,
      fallbackAsync: () => fallbackAsync,
      finite: () => finite,
      flatten: () => flatten,
      getDefault: () => getDefault,
      getDefaultArgs: () => getDefaultArgs2,
      getIssues: () => getIssues2,
      getOutput: () => getOutput2,
      getPipeIssues: () => getPipeIssues,
      getSchemaIssues: () => getSchemaIssues2,
      imei: () => imei,
      includes: () => includes2,
      instance: () => instance,
      instanceAsync: () => instanceAsync,
      integer: () => integer,
      intersection: () => intersection,
      intersectionAsync: () => intersectionAsync,
      ip: () => ip,
      ipv4: () => ipv4,
      ipv6: () => ipv6,
      is: () => is,
      isLuhnAlgo: () => isLuhnAlgo,
      isoDate: () => isoDate,
      isoDateTime: () => isoDateTime,
      isoTime: () => isoTime,
      isoTimeSecond: () => isoTimeSecond,
      isoTimestamp: () => isoTimestamp,
      isoWeek: () => isoWeek,
      keyof: () => keyof,
      length: () => length,
      literal: () => literal2,
      literalAsync: () => literalAsync,
      map: () => map,
      mapAsync: () => mapAsync,
      maxBytes: () => maxBytes,
      maxLength: () => maxLength,
      maxRange: () => maxRange,
      maxSize: () => maxSize,
      maxValue: () => maxValue,
      merge: () => merge,
      mergeAsync: () => mergeAsync,
      mimeType: () => mimeType,
      minBytes: () => minBytes,
      minLength: () => minLength,
      minRange: () => minRange,
      minSize: () => minSize,
      minValue: () => minValue,
      multipleOf: () => multipleOf,
      nan: () => nan,
      nanAsync: () => nanAsync,
      nativeEnum: () => nativeEnum,
      nativeEnumAsync: () => nativeEnumAsync,
      never: () => never,
      neverAsync: () => neverAsync,
      nonNullable: () => nonNullable,
      nonNullableAsync: () => nonNullableAsync,
      nonNullish: () => nonNullish,
      nonNullishAsync: () => nonNullishAsync,
      nonOptional: () => nonOptional,
      nonOptionalAsync: () => nonOptionalAsync,
      notBytes: () => notBytes,
      notLength: () => notLength,
      notSize: () => notSize,
      notValue: () => notValue,
      nullType: () => nullType,
      nullTypeAsync: () => nullTypeAsync,
      nullable: () => nullable,
      nullableAsync: () => nullableAsync,
      nullish: () => nullish,
      nullishAsync: () => nullishAsync,
      number: () => number2,
      numberAsync: () => numberAsync,
      object: () => object2,
      objectAsync: () => objectAsync,
      omit: () => omit,
      omitAsync: () => omitAsync,
      optional: () => optional2,
      optionalAsync: () => optionalAsync,
      parse: () => parse3,
      parseAsync: () => parseAsync,
      partial: () => partial,
      partialAsync: () => partialAsync,
      passthrough: () => passthrough,
      passthroughAsync: () => passthroughAsync,
      pick: () => pick,
      pickAsync: () => pickAsync,
      record: () => record2,
      recordAsync: () => recordAsync,
      recursive: () => recursive2,
      recursiveAsync: () => recursiveAsync,
      regex: () => regex,
      required: () => required,
      requiredAsync: () => requiredAsync,
      safeInteger: () => safeInteger,
      safeParse: () => safeParse,
      safeParseAsync: () => safeParseAsync,
      set: () => set,
      setAsync: () => setAsync,
      size: () => size,
      special: () => special,
      specialAsync: () => specialAsync,
      startsWith: () => startsWith,
      strict: () => strict,
      strictAsync: () => strictAsync,
      string: () => string2,
      stringAsync: () => stringAsync,
      strip: () => strip,
      stripAsync: () => stripAsync,
      symbol: () => symbol,
      symbolAsync: () => symbolAsync,
      toCustom: () => toCustom,
      toCustomAsync: () => toCustomAsync,
      toLowerCase: () => toLowerCase,
      toMaxValue: () => toMaxValue,
      toMinValue: () => toMinValue,
      toTrimmed: () => toTrimmed,
      toTrimmedEnd: () => toTrimmedEnd,
      toTrimmedStart: () => toTrimmedStart,
      toUpperCase: () => toUpperCase,
      transform: () => transform,
      transformAsync: () => transformAsync,
      tuple: () => tuple2,
      tupleAsync: () => tupleAsync,
      ulid: () => ulid,
      undefinedType: () => undefinedType,
      undefinedTypeAsync: () => undefinedTypeAsync,
      union: () => union2,
      unionAsync: () => unionAsync,
      unknown: () => unknown,
      unknownAsync: () => unknownAsync,
      unwrap: () => unwrap,
      url: () => url,
      useDefault: () => useDefault,
      uuid: () => uuid,
      value: () => value,
      voidType: () => voidType,
      voidTypeAsync: () => voidTypeAsync,
      withDefault: () => withDefault
    });
    module2.exports = __toCommonJS2(src_exports);
    function flatten(arg1) {
      return (Array.isArray(arg1) ? arg1 : arg1.issues).reduce(
        (flatErrors, issue) => {
          if (issue.path) {
            if (issue.path.every(
              ({ key }) => typeof key === "string" || typeof key === "number"
            )) {
              const path = issue.path.map(({ key }) => key).join(".");
              if (flatErrors.nested[path]) {
                flatErrors.nested[path].push(issue.message);
              } else {
                flatErrors.nested[path] = [issue.message];
              }
            }
          } else {
            if (flatErrors.root) {
              flatErrors.root.push(issue.message);
            } else {
              flatErrors.root = [issue.message];
            }
          }
          return flatErrors;
        },
        { nested: {} }
      );
    }
    var ValiError = class extends Error {
      issues;
      /**
       * Creates a Valibot error with useful information.
       *
       * @param issues The error issues.
       */
      constructor(issues) {
        super(issues[0].message);
        this.name = "ValiError";
        this.issues = issues;
      }
    };
    var BrandSymbol2 = Symbol("brand");
    function brand(schema2, name) {
      return schema2;
    }
    function coerce(schema2, action) {
      return {
        ...schema2,
        /**
         * Parses unknown input based on its schema.
         *
         * @param input The input to be parsed.
         * @param info The parse info.
         *
         * @returns The parsed output.
         */
        _parse(input, info) {
          return schema2._parse(action(input), info);
        }
      };
    }
    function coerceAsync(schema2, action) {
      return {
        ...schema2,
        /**
         * Parses unknown input based on its schema.
         *
         * @param input The input to be parsed.
         * @param info The parse info.
         *
         * @returns The parsed output.
         */
        async _parse(input, info) {
          return schema2._parse(await action(input), info);
        }
      };
    }
    function getIssues2(issues) {
      return { issues };
    }
    function getOutput2(output) {
      return { output };
    }
    function getIssue2(info, issue) {
      return {
        reason: info?.reason,
        validation: issue.validation,
        origin: info?.origin || "value",
        message: issue.message,
        input: issue.input,
        path: issue.path,
        abortEarly: info?.abortEarly,
        abortPipeEarly: info?.abortPipeEarly,
        skipPipe: info?.skipPipe
      };
    }
    function getPipeInfo2(info, reason) {
      return {
        reason,
        origin: info?.origin,
        abortEarly: info?.abortEarly,
        abortPipeEarly: info?.abortPipeEarly,
        skipPipe: info?.skipPipe
      };
    }
    function executePipe2(input, pipe, parseInfo, reason) {
      if (!pipe || !pipe.length || parseInfo?.skipPipe) {
        return getOutput2(input);
      }
      let pipeInfo;
      let issues;
      let output = input;
      for (const action of pipe) {
        const result = action(output);
        if (result.issues) {
          pipeInfo = pipeInfo || getPipeInfo2(parseInfo, reason);
          for (const issueInfo of result.issues) {
            const issue = getIssue2(pipeInfo, issueInfo);
            issues ? issues.push(issue) : issues = [issue];
          }
          if (pipeInfo.abortEarly || pipeInfo.abortPipeEarly) {
            break;
          }
        } else {
          output = result.output;
        }
      }
      return issues ? getIssues2(issues) : getOutput2(output);
    }
    async function executePipeAsync(input, pipe, parseInfo, reason) {
      if (!pipe || !pipe.length || parseInfo?.skipPipe) {
        return getOutput2(input);
      }
      let pipeInfo;
      let issues;
      let output = input;
      for (const action of pipe) {
        const result = await action(output);
        if (result.issues) {
          pipeInfo = pipeInfo || getPipeInfo2(parseInfo, reason);
          for (const issueInfo of result.issues) {
            const issue = getIssue2(pipeInfo, issueInfo);
            issues ? issues.push(issue) : issues = [issue];
          }
          if (pipeInfo.abortEarly || pipeInfo.abortPipeEarly) {
            break;
          }
        } else {
          output = result.output;
        }
      }
      return issues ? getIssues2(issues) : getOutput2(output);
    }
    function getDefaultArgs2(arg1, arg2) {
      return Array.isArray(arg1) ? [void 0, arg1] : [arg1, arg2];
    }
    function getErrorMessage2(error) {
      return typeof error === "function" ? error() : error;
    }
    function getPipeIssues(validation, error, input) {
      return getIssues2([
        {
          validation,
          message: getErrorMessage2(error),
          input
        }
      ]);
    }
    function getSchemaIssues2(info, reason, validation, error, input, issues) {
      return {
        issues: [
          {
            reason,
            validation,
            origin: info?.origin || "value",
            message: getErrorMessage2(error),
            input,
            issues,
            abortEarly: info?.abortEarly,
            abortPipeEarly: info?.abortPipeEarly,
            skipPipe: info?.skipPipe
          }
        ]
      };
    }
    function isLuhnAlgo(input) {
      const number22 = input.replace(/\D/g, "");
      let length2 = number22.length;
      let bit = 1;
      let sum = 0;
      while (length2) {
        const value2 = +number22[--length2];
        bit ^= 1;
        sum += bit ? [0, 2, 4, 6, 8, 1, 3, 5, 7, 9][value2] : value2;
      }
      return sum % 10 === 0;
    }
    function fallback(schema2, value2) {
      return {
        ...schema2,
        /**
         * Parses unknown input based on its schema.
         *
         * @param input The input to be parsed.
         * @param info The parse info.
         *
         * @returns The parsed output.
         */
        _parse(input, info) {
          const result = schema2._parse(input, info);
          return getOutput2(
            result.issues ? typeof value2 === "function" ? value2({
              input,
              issues: result.issues
            }) : value2 : result.output
          );
        }
      };
    }
    function fallbackAsync(schema2, value2) {
      return {
        ...schema2,
        /**
         * Parses unknown input based on its schema.
         *
         * @param input The input to be parsed.
         * @param info The parse info.
         *
         * @returns The parsed output.
         */
        async _parse(input, info) {
          const result = await schema2._parse(input, info);
          return getOutput2(
            result.issues ? typeof value2 === "function" ? value2({
              input,
              issues: result.issues
            }) : value2 : result.output
          );
        }
      };
    }
    function getDefault(schema2) {
      return schema2.default;
    }
    function is(schema2, input) {
      return !schema2._parse(input, { abortEarly: true }).issues;
    }
    function any2(pipe = []) {
      return {
        /**
         * The schema type.
         */
        schema: "any",
        /**
         * Whether it's async.
         */
        async: false,
        /**
         * Parses unknown input based on its schema.
         *
         * @param input The input to be parsed.
         * @param info The parse info.
         *
         * @returns The parsed output.
         */
        _parse(input, info) {
          return executePipe2(input, pipe, info, "any");
        }
      };
    }
    function anyAsync(pipe = []) {
      return {
        /**
         * The schema type.
         */
        schema: "any",
        /**
         * Whether it's async.
         */
        async: true,
        /**
         * Parses unknown input based on its schema.
         *
         * @param input The input to be parsed.
         * @param info The parse info.
         *
         * @returns The parsed output.
         */
        async _parse(input, info) {
          return executePipeAsync(input, pipe, info, "any");
        }
      };
    }
    function array2(item, arg2, arg3) {
      const [error, pipe] = getDefaultArgs2(arg2, arg3);
      return {
        /**
         * The schema type.
         */
        schema: "array",
        /**
         * The array item schema.
         */
        array: { item },
        /**
         * Whether it's async.
         */
        async: false,
        /**
         * Parses unknown input based on its schema.
         *
         * @param input The input to be parsed.
         * @param info The parse info.
         *
         * @returns The parsed output.
         */
        _parse(input, info) {
          if (!Array.isArray(input)) {
            return getSchemaIssues2(
              info,
              "type",
              "array",
              error || "Invalid type",
              input
            );
          }
          let issues;
          const output = [];
          for (let key = 0; key < input.length; key++) {
            const value2 = input[key];
            const result = item._parse(value2, info);
            if (result.issues) {
              const pathItem = {
                schema: "array",
                input,
                key,
                value: value2
              };
              for (const issue of result.issues) {
                if (issue.path) {
                  issue.path.unshift(pathItem);
                } else {
                  issue.path = [pathItem];
                }
                issues?.push(issue);
              }
              if (!issues) {
                issues = result.issues;
              }
              if (info?.abortEarly) {
                break;
              }
            } else {
              output.push(result.output);
            }
          }
          return issues ? getIssues2(issues) : executePipe2(output, pipe, info, "array");
        }
      };
    }
    function arrayAsync(item, arg2, arg3) {
      const [error, pipe] = getDefaultArgs2(arg2, arg3);
      return {
        /**
         * The schema type.
         */
        schema: "array",
        /**
         * The array item schema.
         */
        array: { item },
        /**
         * Whether it's async.
         */
        async: true,
        /**
         * Parses unknown input based on its schema.
         *
         * @param input The input to be parsed.
         * @param info The parse info.
         *
         * @returns The parsed output.
         */
        async _parse(input, info) {
          if (!Array.isArray(input)) {
            return getSchemaIssues2(
              info,
              "type",
              "array",
              error || "Invalid type",
              input
            );
          }
          let issues;
          const output = [];
          await Promise.all(
            input.map(async (value2, key) => {
              if (!(info?.abortEarly && issues)) {
                const result = await item._parse(value2, info);
                if (!(info?.abortEarly && issues)) {
                  if (result.issues) {
                    const pathItem = {
                      schema: "array",
                      input,
                      key,
                      value: value2
                    };
                    for (const issue of result.issues) {
                      if (issue.path) {
                        issue.path.unshift(pathItem);
                      } else {
                        issue.path = [pathItem];
                      }
                      issues?.push(issue);
                    }
                    if (!issues) {
                      issues = result.issues;
                    }
                    if (info?.abortEarly) {
                      throw null;
                    }
                  } else {
                    output[key] = result.output;
                  }
                }
              }
            })
          ).catch(() => null);
          return issues ? getIssues2(issues) : executePipeAsync(output, pipe, info, "array");
        }
      };
    }
    function bigint(arg1, arg2) {
      const [error, pipe] = getDefaultArgs2(arg1, arg2);
      return {
        /**
         * The schema type.
         */
        schema: "bigint",
        /**
         * Whether it's async.
         */
        async: false,
        /**
         * Parses unknown input based on its schema.
         *
         * @param input The input to be parsed.
         * @param info The parse info.
         *
         * @returns The parsed output.
         */
        _parse(input, info) {
          if (typeof input !== "bigint") {
            return getSchemaIssues2(
              info,
              "type",
              "bigint",
              error || "Invalid type",
              input
            );
          }
          return executePipe2(input, pipe, info, "bigint");
        }
      };
    }
    function bigintAsync(arg1, arg2) {
      const [error, pipe] = getDefaultArgs2(arg1, arg2);
      return {
        /**
         * The schema type.
         */
        schema: "bigint",
        /**
         * Whether it's async.
         */
        async: true,
        /**
         * Parses unknown input based on its schema.
         *
         * @param input The input to be parsed.
         * @param info The parse info.
         *
         * @returns The parsed output.
         */
        async _parse(input, info) {
          if (typeof input !== "bigint") {
            return getSchemaIssues2(
              info,
              "type",
              "bigint",
              error || "Invalid type",
              input
            );
          }
          return executePipeAsync(input, pipe, info, "bigint");
        }
      };
    }
    function blob(arg1, arg2) {
      const [error, pipe] = getDefaultArgs2(arg1, arg2);
      return {
        /**
         * The schema type.
         */
        schema: "blob",
        /**
         * Whether it's async.
         */
        async: false,
        /**
         * Parses unknown input based on its schema.
         *
         * @param input The input to be parsed.
         * @param info The parse info.
         *
         * @returns The parsed output.
         */
        _parse(input, info) {
          if (!(input instanceof Blob)) {
            return getSchemaIssues2(
              info,
              "type",
              "blob",
              error || "Invalid type",
              input
            );
          }
          return executePipe2(input, pipe, info, "blob");
        }
      };
    }
    function blobAsync(arg1, arg2) {
      const [error, pipe] = getDefaultArgs2(arg1, arg2);
      return {
        /**
         * The schema type.
         */
        schema: "blob",
        /**
         * Whether it's async.
         */
        async: true,
        /**
         * Parses unknown input based on its schema.
         *
         * @param input The input to be parsed.
         * @param info The parse info.
         *
         * @returns The parsed output.
         */
        async _parse(input, info) {
          if (!(input instanceof Blob)) {
            return getSchemaIssues2(
              info,
              "type",
              "blob",
              error || "Invalid type",
              input
            );
          }
          return executePipeAsync(input, pipe, info, "blob");
        }
      };
    }
    function boolean2(arg1, arg2) {
      const [error, pipe] = getDefaultArgs2(arg1, arg2);
      return {
        /**
         * The schema type.
         */
        schema: "boolean",
        /**
         * Whether it's async.
         */
        async: false,
        /**
         * Parses unknown input based on its schema.
         *
         * @param input The input to be parsed.
         * @param info The parse info.
         *
         * @returns The parsed output.
         */
        _parse(input, info) {
          if (typeof input !== "boolean") {
            return getSchemaIssues2(
              info,
              "type",
              "boolean",
              error || "Invalid type",
              input
            );
          }
          return executePipe2(input, pipe, info, "boolean");
        }
      };
    }
    function booleanAsync(arg1, arg2) {
      const [error, pipe] = getDefaultArgs2(arg1, arg2);
      return {
        /**
         * The schema type.
         */
        schema: "boolean",
        /**
         * Whether it's async.
         */
        async: true,
        /**
         * Parses unknown input based on its schema.
         *
         * @param input The input to be parsed.
         * @param info The parse info.
         *
         * @returns The parsed output.
         */
        async _parse(input, info) {
          if (typeof input !== "boolean") {
            return getSchemaIssues2(
              info,
              "type",
              "boolean",
              error || "Invalid type",
              input
            );
          }
          return executePipeAsync(input, pipe, info, "boolean");
        }
      };
    }
    function date(arg1, arg2) {
      const [error, pipe] = getDefaultArgs2(arg1, arg2);
      return {
        /**
         * The schema type.
         */
        schema: "date",
        /**
         * Whether it's async.
         */
        async: false,
        /**
         * Parses unknown input based on its schema.
         *
         * @param input The input to be parsed.
         * @param info The parse info.
         *
         * @returns The parsed output.
         */
        _parse(input, info) {
          if (!(input instanceof Date)) {
            return getSchemaIssues2(
              info,
              "type",
              "date",
              error || "Invalid type",
              input
            );
          }
          return executePipe2(input, pipe, info, "date");
        }
      };
    }
    function dateAsync(arg1, arg2) {
      const [error, pipe] = getDefaultArgs2(arg1, arg2);
      return {
        /**
         * The schema type.
         */
        schema: "date",
        /**
         * Whether it's async.
         */
        async: true,
        /**
         * Parses unknown input based on its schema.
         *
         * @param input The input to be parsed.
         * @param info The parse info.
         *
         * @returns The parsed output.
         */
        async _parse(input, info) {
          if (!(input instanceof Date)) {
            return getSchemaIssues2(
              info,
              "type",
              "date",
              error || "Invalid type",
              input
            );
          }
          return executePipeAsync(input, pipe, info, "date");
        }
      };
    }
    function enumType2(enumValue, error) {
      return {
        /**
         * The schema type.
         */
        schema: "enum",
        /**
         * The enum value.
         */
        enum: enumValue,
        /**
         * Whether it's async.
         */
        async: false,
        /**
         * Parses unknown input based on its schema.
         *
         * @param input The input to be parsed.
         * @param info The parse info.
         *
         * @returns The parsed output.
         */
        _parse(input, info) {
          if (!enumValue.includes(input)) {
            return getSchemaIssues2(
              info,
              "type",
              "enum",
              error || "Invalid type",
              input
            );
          }
          return getOutput2(input);
        }
      };
    }
    function enumTypeAsync(enumValue, error) {
      return {
        /**
         * The schema type.
         */
        schema: "enum",
        /**
         * The enum value.
         */
        enum: enumValue,
        /**
         * Whether it's async.
         */
        async: true,
        /**
         * Parses unknown input based on its schema.
         *
         * @param input The input to be parsed.
         * @param info The parse info.
         *
         * @returns The parsed output.
         */
        async _parse(input, info) {
          if (!enumValue.includes(input)) {
            return getSchemaIssues2(
              info,
              "type",
              "enum",
              error || "Invalid type",
              input
            );
          }
          return getOutput2(input);
        }
      };
    }
    function instance(of, arg2, arg3) {
      const [error, pipe] = getDefaultArgs2(arg2, arg3);
      return {
        /**
         * The schema type.
         */
        schema: "instance",
        /**
         * The class of the instance.
         */
        class: of,
        /**
         * Whether it's async.
         */
        async: false,
        /**
         * Parses unknown input based on its schema.
         *
         * @param input The input to be parsed.
         * @param info The parse info.
         *
         * @returns The parsed output.
         */
        _parse(input, info) {
          if (!(input instanceof of)) {
            return getSchemaIssues2(
              info,
              "type",
              "instance",
              error || "Invalid type",
              input
            );
          }
          return executePipe2(input, pipe, info, "instance");
        }
      };
    }
    function instanceAsync(of, arg2, arg3) {
      const [error, pipe] = getDefaultArgs2(arg2, arg3);
      return {
        /**
         * The schema type.
         */
        schema: "instance",
        /**
         * The class of the instance.
         */
        class: of,
        /**
         * Whether it's async.
         */
        async: true,
        /**
         * Parses unknown input based on its schema.
         *
         * @param input The input to be parsed.
         * @param info The parse info.
         *
         * @returns The parsed output.
         */
        async _parse(input, info) {
          if (!(input instanceof of)) {
            return getSchemaIssues2(
              info,
              "type",
              "instance",
              error || "Invalid type",
              input
            );
          }
          return executePipeAsync(input, pipe, info, "instance");
        }
      };
    }
    function mergeOutputs(output1, output2) {
      if (typeof output1 === typeof output2) {
        if (output1 === output2 || output1 instanceof Date && output2 instanceof Date && +output1 === +output2) {
          return getOutput2(output1);
        }
        if (Array.isArray(output1) && Array.isArray(output2)) {
          if (output1.length === output2.length) {
            const array22 = [];
            for (let index = 0; index < output1.length; index++) {
              const result = mergeOutputs(output1[index], output2[index]);
              if (result.invalid) {
                return result;
              }
              array22.push(result.output);
            }
            return getOutput2(array22);
          }
          return { invalid: true };
        }
        if (output1 && output2 && output1.constructor === Object && output2.constructor === Object) {
          const object22 = { ...output1, ...output2 };
          for (const key in output1) {
            if (key in output2) {
              const result = mergeOutputs(output1[key], output2[key]);
              if (result.invalid) {
                return result;
              }
              object22[key] = result.output;
            }
          }
          return getOutput2(object22);
        }
      }
      return { invalid: true };
    }
    function intersection(intersection2, error) {
      return {
        /**
         * The schema type.
         */
        schema: "intersection",
        /**
         * The intersection schema.
         */
        intersection: intersection2,
        /**
         * Whether it's async.
         */
        async: false,
        /**
         * Parses unknown input based on its schema.
         *
         * @param input The input to be parsed.
         * @param info The parse info.
         *
         * @returns The parsed output.
         */
        _parse(input, info) {
          let issues;
          let outputs;
          for (const schema2 of intersection2) {
            const result = schema2._parse(input, info);
            if (result.issues) {
              if (issues) {
                for (const issue of result.issues) {
                  issues.push(issue);
                }
              } else {
                issues = result.issues;
              }
              if (info?.abortEarly) {
                break;
              }
            } else {
              if (outputs) {
                outputs.push(result.output);
              } else {
                outputs = [result.output];
              }
            }
          }
          if (issues) {
            return getIssues2(issues);
          }
          let output = outputs[0];
          for (let index = 1; index < outputs.length; index++) {
            const result = mergeOutputs(output, outputs[index]);
            if (result.invalid) {
              return getSchemaIssues2(
                info,
                "type",
                "intersection",
                error || "Invalid type",
                input
              );
            }
            output = result.output;
          }
          return getOutput2(output);
        }
      };
    }
    function intersectionAsync(intersection2, error) {
      return {
        /**
         * The schema type.
         */
        schema: "intersection",
        /**
         * The intersection schema.
         */
        intersection: intersection2,
        /**
         * Whether it's async.
         */
        async: true,
        /**
         * Parses unknown input based on its schema.
         *
         * @param input The input to be parsed.
         * @param info The parse info.
         *
         * @returns The parsed output.
         */
        async _parse(input, info) {
          let issues;
          let outputs;
          await Promise.all(
            intersection2.map(async (schema2) => {
              if (!(info?.abortEarly && issues)) {
                const result = await schema2._parse(input, info);
                if (!(info?.abortEarly && issues)) {
                  if (result.issues) {
                    if (issues) {
                      for (const issue of result.issues) {
                        issues.push(issue);
                      }
                    } else {
                      issues = result.issues;
                    }
                    if (info?.abortEarly) {
                      throw null;
                    }
                  } else {
                    if (outputs) {
                      outputs.push(result.output);
                    } else {
                      outputs = [result.output];
                    }
                  }
                }
              }
            })
          ).catch(() => null);
          if (issues) {
            return getIssues2(issues);
          }
          let output = outputs[0];
          for (let index = 1; index < outputs.length; index++) {
            const result = mergeOutputs(output, outputs[index]);
            if (result.invalid) {
              return getSchemaIssues2(
                info,
                "type",
                "intersection",
                error || "Invalid type",
                input
              );
            }
            output = result.output;
          }
          return getOutput2(output);
        }
      };
    }
    function literal2(literal22, error) {
      return {
        /**
         * The schema type.
         */
        schema: "literal",
        /**
         * The literal value.
         */
        literal: literal22,
        /**
         * Whether it's async.
         */
        async: false,
        /**
         * Parses unknown input based on its schema.
         *
         * @param input The input to be parsed.
         * @param info The parse info.
         *
         * @returns The parsed output.
         */
        _parse(input, info) {
          if (input !== literal22) {
            return getSchemaIssues2(
              info,
              "type",
              "literal",
              error || "Invalid type",
              input
            );
          }
          return getOutput2(input);
        }
      };
    }
    function literalAsync(literal22, error) {
      return {
        /**
         * The schema type.
         */
        schema: "literal",
        /**
         * The literal value.
         */
        literal: literal22,
        /**
         * Whether it's async.
         */
        async: true,
        /**
         * Parses unknown input based on its schema.
         *
         * @param input The input to be parsed.
         * @param info The parse info.
         *
         * @returns The parsed output.
         */
        async _parse(input, info) {
          if (input !== literal22) {
            return getSchemaIssues2(
              info,
              "type",
              "literal",
              error || "Invalid type",
              input
            );
          }
          return getOutput2(input);
        }
      };
    }
    function map(key, value2, arg3, arg4) {
      const [error, pipe] = getDefaultArgs2(arg3, arg4);
      return {
        /**
         * The schema type.
         */
        schema: "map",
        /**
         * The map key and value schema.
         */
        map: { key, value: value2 },
        /**
         * Whether it's async.
         */
        async: false,
        /**
         * Parses unknown input based on its schema.
         *
         * @param input The input to be parsed.
         * @param info The parse info.
         *
         * @returns The parsed output.
         */
        _parse(input, info) {
          if (!(input instanceof Map)) {
            return getSchemaIssues2(
              info,
              "type",
              "map",
              error || "Invalid type",
              input
            );
          }
          let issues;
          const output = /* @__PURE__ */ new Map();
          for (const [inputKey, inputValue] of input.entries()) {
            let pathItem;
            const keyResult = key._parse(inputKey, {
              origin: "key",
              abortEarly: info?.abortEarly,
              abortPipeEarly: info?.abortPipeEarly,
              skipPipe: info?.skipPipe
            });
            if (keyResult.issues) {
              pathItem = {
                schema: "map",
                input,
                key: inputKey,
                value: inputValue
              };
              for (const issue of keyResult.issues) {
                if (issue.path) {
                  issue.path.unshift(pathItem);
                } else {
                  issue.path = [pathItem];
                }
                issues?.push(issue);
              }
              if (!issues) {
                issues = keyResult.issues;
              }
              if (info?.abortEarly) {
                break;
              }
            }
            const valueResult = value2._parse(inputValue, info);
            if (valueResult.issues) {
              pathItem = pathItem || {
                schema: "map",
                input,
                key: inputKey,
                value: inputValue
              };
              for (const issue of valueResult.issues) {
                if (issue.path) {
                  issue.path.unshift(pathItem);
                } else {
                  issue.path = [pathItem];
                }
                issues?.push(issue);
              }
              if (!issues) {
                issues = valueResult.issues;
              }
              if (info?.abortEarly) {
                break;
              }
            }
            if (!keyResult.issues && !valueResult.issues) {
              output.set(keyResult.output, valueResult.output);
            }
          }
          return issues ? getIssues2(issues) : executePipe2(output, pipe, info, "map");
        }
      };
    }
    function mapAsync(key, value2, arg3, arg4) {
      const [error, pipe] = getDefaultArgs2(arg3, arg4);
      return {
        /**
         * The schema type.
         */
        schema: "map",
        /**
         * The map key and value schema.
         */
        map: { key, value: value2 },
        /**
         * Whether it's async.
         */
        async: true,
        /**
         * Parses unknown input based on its schema.
         *
         * @param input The input to be parsed.
         * @param info The parse info.
         *
         * @returns The parsed output.
         */
        async _parse(input, info) {
          if (!(input instanceof Map)) {
            return getSchemaIssues2(
              info,
              "type",
              "map",
              error || "Invalid type",
              input
            );
          }
          const output = /* @__PURE__ */ new Map();
          let issues;
          await Promise.all(
            Array.from(input.entries()).map(async ([inputKey, inputValue]) => {
              let pathItem;
              const [keyResult, valueResult] = await Promise.all(
                [
                  { schema: key, value: inputKey, origin: "key" },
                  { schema: value2, value: inputValue, origin: "value" }
                ].map(async ({ schema: schema2, value: value3, origin }) => {
                  if (!(info?.abortEarly && issues)) {
                    const result = await schema2._parse(value3, {
                      origin,
                      abortEarly: info?.abortEarly,
                      abortPipeEarly: info?.abortPipeEarly,
                      skipPipe: info?.skipPipe
                    });
                    if (!(info?.abortEarly && issues)) {
                      if (result.issues) {
                        pathItem = pathItem || {
                          schema: "map",
                          input,
                          key: inputKey,
                          value: inputValue
                        };
                        for (const issue of result.issues) {
                          if (issue.path) {
                            issue.path.unshift(pathItem);
                          } else {
                            issue.path = [pathItem];
                          }
                          issues?.push(issue);
                        }
                        if (!issues) {
                          issues = result.issues;
                        }
                        if (info?.abortEarly) {
                          throw null;
                        }
                      } else {
                        return result;
                      }
                    }
                  }
                })
              ).catch(() => []);
              if (keyResult && valueResult) {
                output.set(keyResult.output, valueResult.output);
              }
            })
          );
          return issues ? getIssues2(issues) : executePipeAsync(input, pipe, info, "map");
        }
      };
    }
    function nan(error) {
      return {
        /**
         * The schema type.
         */
        schema: "nan",
        /**
         * Whether it's async.
         */
        async: false,
        /**
         * Parses unknown input based on its schema.
         *
         * @param input The input to be parsed.
         * @param info The parse info.
         *
         * @returns The parsed output.
         */
        _parse(input, info) {
          if (!Number.isNaN(input)) {
            return getSchemaIssues2(
              info,
              "type",
              "nan",
              error || "Invalid type",
              input
            );
          }
          return getOutput2(input);
        }
      };
    }
    function nanAsync(error) {
      return {
        /**
         * The schema type.
         */
        schema: "nan",
        /**
         * Whether it's async.
         */
        async: true,
        /**
         * Parses unknown input based on its schema.
         *
         * @param input The input to be parsed.
         * @param info The parse info.
         *
         * @returns The parsed output.
         */
        async _parse(input, info) {
          if (!Number.isNaN(input)) {
            return getSchemaIssues2(
              info,
              "type",
              "nan",
              error || "Invalid type",
              input
            );
          }
          return getOutput2(input);
        }
      };
    }
    function nativeEnum(nativeEnum2, error) {
      return {
        /**
         * The schema type.
         */
        schema: "native_enum",
        /**
         * The native enum value.
         */
        nativeEnum: nativeEnum2,
        /**
         * Whether it's async.
         */
        async: false,
        /**
         * Parses unknown input based on its schema.
         *
         * @param input The input to be parsed.
         * @param info The parse info.
         *
         * @returns The parsed output.
         */
        _parse(input, info) {
          if (!Object.values(nativeEnum2).includes(input)) {
            return getSchemaIssues2(
              info,
              "type",
              "native_enum",
              error || "Invalid type",
              input
            );
          }
          return getOutput2(input);
        }
      };
    }
    function nativeEnumAsync(nativeEnum2, error) {
      return {
        /**
         * The schema type.
         */
        schema: "native_enum",
        /**
         * The native enum value.
         */
        nativeEnum: nativeEnum2,
        /**
         * Whether it's async.
         */
        async: true,
        /**
         * Parses unknown input based on its schema.
         *
         * @param input The input to be parsed.
         * @param info The parse info.
         *
         * @returns The parsed output.
         */
        async _parse(input, info) {
          if (!Object.values(nativeEnum2).includes(input)) {
            return getSchemaIssues2(
              info,
              "type",
              "native_enum",
              error || "Invalid type",
              input
            );
          }
          return getOutput2(input);
        }
      };
    }
    function never(error) {
      return {
        /**
         * The schema type.
         */
        schema: "never",
        /**
         * Whether it's async.
         */
        async: false,
        /**
         * Parses unknown input based on its schema.
         *
         * @param input The input to be parsed.
         * @param info The parse info.
         *
         * @returns The parsed output.
         */
        _parse(input, info) {
          return getSchemaIssues2(
            info,
            "type",
            "never",
            error || "Invalid type",
            input
          );
        }
      };
    }
    function neverAsync(error) {
      return {
        /**
         * The schema type.
         */
        schema: "never",
        /**
         * Whether it's async.
         */
        async: true,
        /**
         * Parses unknown input based on its schema.
         *
         * @param input The input to be parsed.
         * @param info The parse info.
         *
         * @returns The parsed output.
         */
        async _parse(input, info) {
          return getSchemaIssues2(
            info,
            "type",
            "never",
            error || "Invalid type",
            input
          );
        }
      };
    }
    function nonNullable(wrapped, error) {
      return {
        /**
         * The schema type.
         */
        schema: "non_nullable",
        /**
         * The wrapped schema.
         */
        wrapped,
        /**
         * Whether it's async.
         */
        async: false,
        /**
         * Parses unknown input based on its schema.
         *
         * @param input The input to be parsed.
         * @param info The parse info.
         *
         * @returns The parsed output.
         */
        _parse(input, info) {
          if (input === null) {
            return getSchemaIssues2(
              info,
              "type",
              "non_nullable",
              error || "Invalid type",
              input
            );
          }
          return wrapped._parse(input, info);
        }
      };
    }
    function nonNullableAsync(wrapped, error) {
      return {
        /**
         * The schema type.
         */
        schema: "non_nullable",
        /**
         * The wrapped schema.
         */
        wrapped,
        /**
         * Whether it's async.
         */
        async: true,
        /**
         * Parses unknown input based on its schema.
         *
         * @param input The input to be parsed.
         * @param info The parse info.
         *
         * @returns The parsed output.
         */
        async _parse(input, info) {
          if (input === null) {
            return getSchemaIssues2(
              info,
              "type",
              "non_nullable",
              error || "Invalid type",
              input
            );
          }
          return wrapped._parse(input, info);
        }
      };
    }
    function nonNullish(wrapped, error) {
      return {
        /**
         * The schema type.
         */
        schema: "non_nullish",
        /**
         * The wrapped schema.
         */
        wrapped,
        /**
         * Whether it's async.
         */
        async: false,
        /**
         * Parses unknown input based on its schema.
         *
         * @param input The input to be parsed.
         * @param info The parse info.
         *
         * @returns The parsed output.
         */
        _parse(input, info) {
          if (input === null || input === void 0) {
            return getSchemaIssues2(
              info,
              "type",
              "non_nullish",
              error || "Invalid type",
              input
            );
          }
          return wrapped._parse(input, info);
        }
      };
    }
    function nonNullishAsync(wrapped, error) {
      return {
        /**
         * The schema type.
         */
        schema: "non_nullish",
        /**
         * The wrapped schema.
         */
        wrapped,
        /**
         * Whether it's async.
         */
        async: true,
        /**
         * Parses unknown input based on its schema.
         *
         * @param input The input to be parsed.
         * @param info The parse info.
         *
         * @returns The parsed output.
         */
        async _parse(input, info) {
          if (input === null || input === void 0) {
            return getSchemaIssues2(
              info,
              "type",
              "non_nullish",
              error || "Invalid type",
              input
            );
          }
          return wrapped._parse(input, info);
        }
      };
    }
    function nonOptional(wrapped, error) {
      return {
        /**
         * The schema type.
         */
        schema: "non_optional",
        /**
         * The wrapped schema.
         */
        wrapped,
        /**
         * Whether it's async.
         */
        async: false,
        /**
         * Parses unknown input based on its schema.
         *
         * @param input The input to be parsed.
         * @param info The parse info.
         *
         * @returns The parsed output.
         */
        _parse(input, info) {
          if (input === void 0) {
            return getSchemaIssues2(
              info,
              "type",
              "non_optional",
              error || "Invalid type",
              input
            );
          }
          return wrapped._parse(input, info);
        }
      };
    }
    function nonOptionalAsync(wrapped, error) {
      return {
        /**
         * The schema type.
         */
        schema: "non_optional",
        /**
         * The wrapped schema.
         */
        wrapped,
        /**
         * Whether it's async.
         */
        async: true,
        /**
         * Parses unknown input based on its schema.
         *
         * @param input The input to be parsed.
         * @param info The parse info.
         *
         * @returns The parsed output.
         */
        async _parse(input, info) {
          if (input === void 0) {
            return getSchemaIssues2(
              info,
              "type",
              "non_optional",
              error || "Invalid type",
              input
            );
          }
          return wrapped._parse(input, info);
        }
      };
    }
    function nullable(wrapped, default_) {
      return {
        /**
         * The schema type.
         */
        schema: "nullable",
        /**
         * The wrapped schema.
         */
        wrapped,
        /**
         * The default value.
         */
        get default() {
          return typeof default_ === "function" ? default_() : default_;
        },
        /**
         * Whether it's async.
         */
        async: false,
        /**
         * Parses unknown input based on its schema.
         *
         * @param input The input to be parsed.
         * @param info The parse info.
         *
         * @returns The parsed output.
         */
        _parse(input, info) {
          let default_2;
          const value2 = input === null && (default_2 = this.default) && default_2 !== void 0 ? default_2 : input;
          if (value2 === null) {
            return getOutput2(value2);
          }
          return wrapped._parse(value2, info);
        }
      };
    }
    function nullableAsync(wrapped, default_) {
      return {
        /**
         * The schema type.
         */
        schema: "nullable",
        /**
         * The wrapped schema.
         */
        wrapped,
        /**
         * The default value.
         */
        get default() {
          return typeof default_ === "function" ? default_() : default_;
        },
        /**
         * Whether it's async.
         */
        async: true,
        /**
         * Parses unknown input based on its schema.
         *
         * @param input The input to be parsed.
         * @param info The parse info.
         *
         * @returns The parsed output.
         */
        async _parse(input, info) {
          let default_2;
          const value2 = input === null && (default_2 = await this.default) && default_2 !== void 0 ? default_2 : input;
          if (value2 === null) {
            return getOutput2(value2);
          }
          return wrapped._parse(value2, info);
        }
      };
    }
    function nullish(wrapped, default_) {
      return {
        /**
         * The schema type.
         */
        schema: "nullish",
        /**
         * The wrapped schema.
         */
        wrapped,
        /**
         * The default value.
         */
        get default() {
          return typeof default_ === "function" ? default_() : default_;
        },
        /**
         * Whether it's async.
         */
        async: false,
        /**
         * Parses unknown input based on its schema.
         *
         * @param input The input to be parsed.
         * @param info The parse info.
         *
         * @returns The parsed output.
         */
        _parse(input, info) {
          let default_2;
          const value2 = (input === null || input === void 0) && (default_2 = this.default) && default_2 !== void 0 ? default_2 : input;
          if (value2 === null || value2 === void 0) {
            return getOutput2(value2);
          }
          return wrapped._parse(value2, info);
        }
      };
    }
    function nullishAsync(wrapped, default_) {
      return {
        /**
         * The schema type.
         */
        schema: "nullish",
        /**
         * The wrapped schema.
         */
        wrapped,
        /**
         * The default value.
         */
        get default() {
          return typeof default_ === "function" ? default_() : default_;
        },
        /**
         * Whether it's async.
         */
        async: true,
        /**
         * Parses unknown input based on its schema.
         *
         * @param input The input to be parsed.
         * @param info The parse info.
         *
         * @returns The parsed output.
         */
        async _parse(input, info) {
          let default_2;
          const value2 = (input === null || input === void 0) && (default_2 = await this.default) && default_2 !== void 0 ? default_2 : input;
          if (value2 === null || value2 === void 0) {
            return getOutput2(value2);
          }
          return wrapped._parse(value2, info);
        }
      };
    }
    function nullType(error) {
      return {
        /**
         * The schema type.
         */
        schema: "null",
        /**
         * Whether it's async.
         */
        async: false,
        /**
         * Parses unknown input based on its schema.
         *
         * @param input The input to be parsed.
         * @param info The parse info.
         *
         * @returns The parsed output.
         */
        _parse(input, info) {
          if (input !== null) {
            return getSchemaIssues2(
              info,
              "type",
              "null",
              error || "Invalid type",
              input
            );
          }
          return getOutput2(input);
        }
      };
    }
    function nullTypeAsync(error) {
      return {
        /**
         * The schema type.
         */
        schema: "null",
        /**
         * Whether it's async.
         */
        async: true,
        /**
         * Parses unknown input based on its schema.
         *
         * @param input The input to be parsed.
         * @param info The parse info.
         *
         * @returns The parsed output.
         */
        async _parse(input, info) {
          if (input !== null) {
            return getSchemaIssues2(
              info,
              "type",
              "null",
              error || "Invalid type",
              input
            );
          }
          return getOutput2(input);
        }
      };
    }
    function number2(arg1, arg2) {
      const [error, pipe] = getDefaultArgs2(arg1, arg2);
      return {
        /**
         * The schema type.
         */
        schema: "number",
        /**
         * Whether it's async.
         */
        async: false,
        /**
         * Parses unknown input based on its schema.
         *
         * @param input The input to be parsed.
         * @param info The parse info.
         *
         * @returns The parsed output.
         */
        _parse(input, info) {
          if (typeof input !== "number" || Number.isNaN(input)) {
            return getSchemaIssues2(
              info,
              "type",
              "number",
              error || "Invalid type",
              input
            );
          }
          return executePipe2(input, pipe, info, "number");
        }
      };
    }
    function numberAsync(arg1, arg2) {
      const [error, pipe] = getDefaultArgs2(arg1, arg2);
      return {
        /**
         * The schema type.
         */
        schema: "number",
        /**
         * Whether it's async.
         */
        async: true,
        /**
         * Parses unknown input based on its schema.
         *
         * @param input The input to be parsed.
         * @param info The parse info.
         *
         * @returns The parsed output.
         */
        async _parse(input, info) {
          if (typeof input !== "number" || Number.isNaN(input)) {
            return getSchemaIssues2(
              info,
              "type",
              "number",
              error || "Invalid type",
              input
            );
          }
          return executePipeAsync(input, pipe, info, "number");
        }
      };
    }
    function object2(object22, arg2, arg3) {
      const [error, pipe] = getDefaultArgs2(arg2, arg3);
      let cachedEntries;
      return {
        /**
         * The schema type.
         */
        schema: "object",
        /**
         * The object schema.
         */
        object: object22,
        /**
         * Whether it's async.
         */
        async: false,
        /**
         * Parses unknown input based on its schema.
         *
         * @param input The input to be parsed.
         * @param info The parse info.
         *
         * @returns The parsed output.
         */
        _parse(input, info) {
          if (!input || typeof input !== "object") {
            return getSchemaIssues2(
              info,
              "type",
              "object",
              error || "Invalid type",
              input
            );
          }
          cachedEntries = cachedEntries || Object.entries(object22);
          let issues;
          const output = {};
          for (const [key, schema2] of cachedEntries) {
            const value2 = input[key];
            const result = schema2._parse(value2, info);
            if (result.issues) {
              const pathItem = {
                schema: "object",
                input,
                key,
                value: value2
              };
              for (const issue of result.issues) {
                if (issue.path) {
                  issue.path.unshift(pathItem);
                } else {
                  issue.path = [pathItem];
                }
                issues?.push(issue);
              }
              if (!issues) {
                issues = result.issues;
              }
              if (info?.abortEarly) {
                break;
              }
            } else if (result.output !== void 0 || key in input) {
              output[key] = result.output;
            }
          }
          return issues ? getIssues2(issues) : executePipe2(
            output,
            pipe,
            info,
            "object"
          );
        }
      };
    }
    function objectAsync(object22, arg2, arg3) {
      const [error, pipe] = getDefaultArgs2(arg2, arg3);
      let cachedEntries;
      return {
        /**
         * The schema type.
         */
        schema: "object",
        /**
         * The object schema.
         */
        object: object22,
        /**
         * Whether it's async.
         */
        async: true,
        /**
         * Parses unknown input based on its schema.
         *
         * @param input The input to be parsed.
         * @param info The parse info.
         *
         * @returns The parsed output.
         */
        async _parse(input, info) {
          if (!input || typeof input !== "object") {
            return getSchemaIssues2(
              info,
              "type",
              "object",
              error || "Invalid type",
              input
            );
          }
          cachedEntries = cachedEntries || Object.entries(object22);
          let issues;
          const output = {};
          await Promise.all(
            cachedEntries.map(async ([key, schema2]) => {
              if (!(info?.abortEarly && issues)) {
                const value2 = input[key];
                const result = await schema2._parse(value2, info);
                if (!(info?.abortEarly && issues)) {
                  if (result.issues) {
                    const pathItem = {
                      schema: "object",
                      input,
                      key,
                      value: value2
                    };
                    for (const issue of result.issues) {
                      if (issue.path) {
                        issue.path.unshift(pathItem);
                      } else {
                        issue.path = [pathItem];
                      }
                      issues?.push(issue);
                    }
                    if (!issues) {
                      issues = result.issues;
                    }
                    if (info?.abortEarly) {
                      throw null;
                    }
                  } else if (result.output !== void 0 || key in input) {
                    output[key] = result.output;
                  }
                }
              }
            })
          ).catch(() => null);
          return issues ? getIssues2(issues) : executePipeAsync(
            output,
            pipe,
            info,
            "object"
          );
        }
      };
    }
    function optional2(wrapped, default_) {
      return {
        /**
         * The schema type.
         */
        schema: "optional",
        /**
         * The wrapped schema.
         */
        wrapped,
        /**
         * The default value.
         */
        get default() {
          return typeof default_ === "function" ? default_() : default_;
        },
        /**
         * Whether it's async.
         */
        async: false,
        /**
         * Parses unknown input based on its schema.
         *
         * @param input The input to be parsed.
         * @param info The parse info.
         *
         * @returns The parsed output.
         */
        _parse(input, info) {
          const value2 = input === void 0 ? this.default : input;
          if (value2 === void 0) {
            return getOutput2(value2);
          }
          return wrapped._parse(value2, info);
        }
      };
    }
    function optionalAsync(wrapped, default_) {
      return {
        /**
         * The schema type.
         */
        schema: "optional",
        /**
         * The wrapped schema.
         */
        wrapped,
        /**
         * The default value.
         */
        get default() {
          return typeof default_ === "function" ? default_() : default_;
        },
        /**
         * Whether it's async.
         */
        async: true,
        /**
         * Parses unknown input based on its schema.
         *
         * @param input The input to be parsed.
         * @param info The parse info.
         *
         * @returns The parsed output.
         */
        async _parse(input, info) {
          const value2 = input === void 0 ? await this.default : input;
          if (value2 === void 0) {
            return getOutput2(value2);
          }
          return wrapped._parse(value2, info);
        }
      };
    }
    function string2(arg1, arg2) {
      const [error, pipe] = getDefaultArgs2(arg1, arg2);
      return {
        /**
         * The schema type.
         */
        schema: "string",
        /**
         * Whether it's async.
         */
        async: false,
        /**
         * Parses unknown input based on its schema.
         *
         * @param input The input to be parsed.
         * @param info The parse info.
         *
         * @returns The parsed output.
         */
        _parse(input, info) {
          if (typeof input !== "string") {
            return getSchemaIssues2(
              info,
              "type",
              "string",
              error || "Invalid type",
              input
            );
          }
          return executePipe2(input, pipe, info, "string");
        }
      };
    }
    function stringAsync(arg1, arg2) {
      const [error, pipe] = getDefaultArgs2(arg1, arg2);
      return {
        /**
         * The schema type.
         */
        schema: "string",
        /**
         * Whether it's async.
         */
        async: true,
        /**
         * Parses unknown input based on its schema.
         *
         * @param input The input to be parsed.
         * @param info The parse info.
         *
         * @returns The parsed output.
         */
        async _parse(input, info) {
          if (typeof input !== "string") {
            return getSchemaIssues2(
              info,
              "type",
              "string",
              error || "Invalid type",
              input
            );
          }
          return executePipeAsync(input, pipe, info, "string");
        }
      };
    }
    function getRecordArgs2(arg1, arg2, arg3, arg4) {
      if (typeof arg2 === "object" && !Array.isArray(arg2)) {
        const [error2, pipe2] = getDefaultArgs2(arg3, arg4);
        return [arg1, arg2, error2, pipe2];
      }
      const [error, pipe] = getDefaultArgs2(
        arg2,
        arg3
      );
      return [string2(), arg1, error, pipe];
    }
    var BLOCKED_KEYS2 = ["__proto__", "prototype", "constructor"];
    function record2(arg1, arg2, arg3, arg4) {
      const [key, value2, error, pipe] = getRecordArgs2(arg1, arg2, arg3, arg4);
      return {
        /**
         * The schema type.
         */
        schema: "record",
        /**
         * The record key and value schema.
         */
        record: { key, value: value2 },
        /**
         * Whether it's async.
         */
        async: false,
        /**
         * Parses unknown input based on its schema.
         *
         * @param input The input to be parsed.
         * @param info The parse info.
         *
         * @returns The parsed output.
         */
        _parse(input, info) {
          if (!input || typeof input !== "object") {
            return getSchemaIssues2(
              info,
              "type",
              "record",
              error || "Invalid type",
              input
            );
          }
          let issues;
          const output = {};
          for (const [inputKey, inputValue] of Object.entries(input)) {
            if (!BLOCKED_KEYS2.includes(inputKey)) {
              let pathItem;
              const keyResult = key._parse(inputKey, {
                origin: "key",
                abortEarly: info?.abortEarly,
                abortPipeEarly: info?.abortPipeEarly,
                skipPipe: info?.skipPipe
              });
              if (keyResult.issues) {
                pathItem = {
                  schema: "record",
                  input,
                  key: inputKey,
                  value: inputValue
                };
                for (const issue of keyResult.issues) {
                  issue.path = [pathItem];
                  issues?.push(issue);
                }
                if (!issues) {
                  issues = keyResult.issues;
                }
                if (info?.abortEarly) {
                  break;
                }
              }
              const valueResult = value2._parse(inputValue, info);
              if (valueResult.issues) {
                pathItem = pathItem || {
                  schema: "record",
                  input,
                  key: inputKey,
                  value: inputValue
                };
                for (const issue of valueResult.issues) {
                  if (issue.path) {
                    issue.path.unshift(pathItem);
                  } else {
                    issue.path = [pathItem];
                  }
                  issues?.push(issue);
                }
                if (!issues) {
                  issues = valueResult.issues;
                }
                if (info?.abortEarly) {
                  break;
                }
              }
              if (!keyResult.issues && !valueResult.issues) {
                output[keyResult.output] = valueResult.output;
              }
            }
          }
          return issues ? getIssues2(issues) : executePipe2(
            output,
            pipe,
            info,
            "record"
          );
        }
      };
    }
    function recordAsync(arg1, arg2, arg3, arg4) {
      const [key, value2, error, pipe] = getRecordArgs2(arg1, arg2, arg3, arg4);
      return {
        /**
         * The schema type.
         */
        schema: "record",
        /**
         * The record key and value schema.
         */
        record: { key, value: value2 },
        /**
         * Whether it's async.
         */
        async: true,
        /**
         * Parses unknown input based on its schema.
         *
         * @param input The input to be parsed.
         * @param info The parse info.
         *
         * @returns The parsed output.
         */
        async _parse(input, info) {
          if (!input || typeof input !== "object") {
            return getSchemaIssues2(
              info,
              "type",
              "record",
              error || "Invalid type",
              input
            );
          }
          let issues;
          const output = {};
          await Promise.all(
            // Note: `Object.entries(...)` converts each key to a string
            Object.entries(input).map(async ([inputKey, inputValue]) => {
              if (!BLOCKED_KEYS2.includes(inputKey)) {
                let pathItem;
                const [keyResult, valueResult] = await Promise.all(
                  [
                    { schema: key, value: inputKey, origin: "key" },
                    { schema: value2, value: inputValue, origin: "value" }
                  ].map(async ({ schema: schema2, value: value3, origin }) => {
                    if (!(info?.abortEarly && issues)) {
                      const result = await schema2._parse(value3, {
                        origin,
                        abortEarly: info?.abortEarly,
                        abortPipeEarly: info?.abortPipeEarly,
                        skipPipe: info?.skipPipe
                      });
                      if (!(info?.abortEarly && issues)) {
                        if (result.issues) {
                          pathItem = pathItem || {
                            schema: "record",
                            input,
                            key: inputKey,
                            value: inputValue
                          };
                          for (const issue of result.issues) {
                            if (issue.path) {
                              issue.path.unshift(pathItem);
                            } else {
                              issue.path = [pathItem];
                            }
                            issues?.push(issue);
                          }
                          if (!issues) {
                            issues = result.issues;
                          }
                          if (info?.abortEarly) {
                            throw null;
                          }
                        } else {
                          return result;
                        }
                      }
                    }
                  })
                ).catch(() => []);
                if (keyResult && valueResult) {
                  output[keyResult.output] = valueResult.output;
                }
              }
            })
          );
          return issues ? getIssues2(issues) : executePipeAsync(
            output,
            pipe,
            info,
            "record"
          );
        }
      };
    }
    function recursive2(getter) {
      return {
        /**
         * The schema type.
         */
        schema: "recursive",
        /**
         * The schema getter.
         */
        getter,
        /**
         * Whether it's async.
         */
        async: false,
        /**
         * Parses unknown input based on its schema.
         *
         * @param input The input to be parsed.
         * @param info The parse info.
         *
         * @returns The parsed output.
         */
        _parse(input, info) {
          return getter()._parse(input, info);
        }
      };
    }
    function recursiveAsync(getter) {
      return {
        /**
         * The schema type.
         */
        schema: "recursive",
        /**
         * The schema getter.
         */
        getter,
        /**
         * Whether it's async.
         */
        async: true,
        /**
         * Parses unknown input based on its schema.
         *
         * @param input The input to be parsed.
         * @param info The parse info.
         *
         * @returns The parsed output.
         */
        async _parse(input, info) {
          return getter()._parse(input, info);
        }
      };
    }
    function set(value2, arg2, arg3) {
      const [error, pipe] = getDefaultArgs2(arg2, arg3);
      return {
        /**
         * The schema type.
         */
        schema: "set",
        /**
         * The set value schema.
         */
        set: { value: value2 },
        /**
         * Whether it's async.
         */
        async: false,
        /**
         * Parses unknown input based on its schema.
         *
         * @param input The input to be parsed.
         * @param info The parse info.
         *
         * @returns The parsed output.
         */
        _parse(input, info) {
          if (!(input instanceof Set)) {
            return getSchemaIssues2(
              info,
              "type",
              "set",
              error || "Invalid type",
              input
            );
          }
          let key = 0;
          let issues;
          const output = /* @__PURE__ */ new Set();
          for (const inputValue of input) {
            const result = value2._parse(inputValue, info);
            if (result.issues) {
              const pathItem = {
                schema: "set",
                input,
                key,
                value: inputValue
              };
              for (const issue of result.issues) {
                if (issue.path) {
                  issue.path.unshift(pathItem);
                } else {
                  issue.path = [pathItem];
                }
                issues?.push(issue);
              }
              if (!issues) {
                issues = result.issues;
              }
              if (info?.abortEarly) {
                break;
              }
            } else {
              output.add(result.output);
            }
            key++;
          }
          return issues ? getIssues2(issues) : executePipe2(output, pipe, info, "set");
        }
      };
    }
    function setAsync(value2, arg2, arg3) {
      const [error, pipe] = getDefaultArgs2(arg2, arg3);
      return {
        /**
         * The schema type.
         */
        schema: "set",
        /**
         * The set value schema.
         */
        set: { value: value2 },
        /**
         * Whether it's async.
         */
        async: true,
        /**
         * Parses unknown input based on its schema.
         *
         * @param input The input to be parsed.
         * @param info The parse info.
         *
         * @returns The parsed output.
         */
        async _parse(input, info) {
          if (!(input instanceof Set)) {
            return getSchemaIssues2(
              info,
              "type",
              "set",
              error || "Invalid type",
              input
            );
          }
          let issues;
          const output = /* @__PURE__ */ new Set();
          await Promise.all(
            Array.from(input.values()).map(async (inputValue, key) => {
              if (!(info?.abortEarly && issues)) {
                const result = await value2._parse(inputValue, info);
                if (!(info?.abortEarly && issues)) {
                  if (result.issues) {
                    const pathItem = {
                      schema: "set",
                      input,
                      key,
                      value: inputValue
                    };
                    for (const issue of result.issues) {
                      if (issue.path) {
                        issue.path.unshift(pathItem);
                      } else {
                        issue.path = [pathItem];
                      }
                      issues?.push(issue);
                    }
                    if (!issues) {
                      issues = result.issues;
                    }
                    if (info?.abortEarly) {
                      throw null;
                    }
                  } else {
                    output.add(result.output);
                  }
                }
              }
            })
          ).catch(() => null);
          return issues ? getIssues2(issues) : executePipeAsync(input, pipe, info, "set");
        }
      };
    }
    function special(check, arg2, arg3) {
      const [error, pipe] = getDefaultArgs2(arg2, arg3);
      return {
        /**
         * The schema type.
         */
        schema: "special",
        /**
         * Whether it's async.
         */
        async: false,
        /**
         * Parses unknown input based on its schema.
         *
         * @param input The input to be parsed.
         * @param info The parse info.
         *
         * @returns The parsed output.
         */
        _parse(input, info) {
          if (!check(input)) {
            return getSchemaIssues2(
              info,
              "type",
              "special",
              error || "Invalid type",
              input
            );
          }
          return executePipe2(input, pipe, info, "special");
        }
      };
    }
    function specialAsync(check, arg2, arg3) {
      const [error, pipe] = getDefaultArgs2(arg2, arg3);
      return {
        /**
         * The schema type.
         */
        schema: "special",
        /**
         * Whether it's async.
         */
        async: true,
        /**
         * Parses unknown input based on its schema.
         *
         * @param input The input to be parsed.
         * @param info The parse info.
         *
         * @returns The parsed output.
         */
        async _parse(input, info) {
          if (!await check(input)) {
            return getSchemaIssues2(
              info,
              "type",
              "special",
              error || "Invalid type",
              input
            );
          }
          return executePipeAsync(input, pipe, info, "special");
        }
      };
    }
    function symbol(error) {
      return {
        /**
         * The schema type.
         */
        schema: "symbol",
        /**
         * Whether it's async.
         */
        async: false,
        /**
         * Parses unknown input based on its schema.
         *
         * @param input The input to be parsed.
         * @param info The parse info.
         *
         * @returns The parsed output.
         */
        _parse(input, info) {
          if (typeof input !== "symbol") {
            return getSchemaIssues2(
              info,
              "type",
              "symbol",
              error || "Invalid type",
              input
            );
          }
          return getOutput2(input);
        }
      };
    }
    function symbolAsync(error) {
      return {
        /**
         * The schema type.
         */
        schema: "symbol",
        /**
         * Whether it's async.
         */
        async: true,
        /**
         * Parses unknown input based on its schema.
         *
         * @param input The input to be parsed.
         * @param info The parse info.
         *
         * @returns The parsed output.
         */
        async _parse(input, info) {
          if (typeof input !== "symbol") {
            return getSchemaIssues2(
              info,
              "type",
              "symbol",
              error || "Invalid type",
              input
            );
          }
          return getOutput2(input);
        }
      };
    }
    function getTupleArgs2(arg1, arg2, arg3) {
      if (typeof arg1 === "object" && !Array.isArray(arg1)) {
        const [error2, pipe2] = getDefaultArgs2(arg2, arg3);
        return [arg1, error2, pipe2];
      }
      const [error, pipe] = getDefaultArgs2(
        arg1,
        arg2
      );
      return [void 0, error, pipe];
    }
    function tuple2(items, arg2, arg3, arg4) {
      const [rest, error, pipe] = getTupleArgs2(arg2, arg3, arg4);
      return {
        /**
         * The schema type.
         */
        schema: "tuple",
        /**
         * The tuple items and rest schema.
         */
        tuple: { items, rest },
        /**
         * Whether it's async.
         */
        async: false,
        /**
         * Parses unknown input based on its schema.
         *
         * @param input The input to be parsed.
         * @param info The parse info.
         *
         * @returns The parsed output.
         */
        _parse(input, info) {
          if (!Array.isArray(input) || !rest && items.length !== input.length || rest && items.length > input.length) {
            return getSchemaIssues2(
              info,
              "type",
              "tuple",
              error || "Invalid type",
              input
            );
          }
          let issues;
          const output = [];
          for (let key = 0; key < items.length; key++) {
            const value2 = input[key];
            const result = items[key]._parse(value2, info);
            if (result.issues) {
              const pathItem = {
                schema: "tuple",
                input,
                key,
                value: value2
              };
              for (const issue of result.issues) {
                if (issue.path) {
                  issue.path.unshift(pathItem);
                } else {
                  issue.path = [pathItem];
                }
                issues?.push(issue);
              }
              if (!issues) {
                issues = result.issues;
              }
              if (info?.abortEarly) {
                break;
              }
            } else {
              output[key] = result.output;
            }
          }
          if (rest) {
            for (let key = items.length; key < input.length; key++) {
              const value2 = input[key];
              const result = rest._parse(value2, info);
              if (result.issues) {
                const pathItem = {
                  schema: "tuple",
                  input,
                  key,
                  value: value2
                };
                for (const issue of result.issues) {
                  if (issue.path) {
                    issue.path.unshift(pathItem);
                  } else {
                    issue.path = [pathItem];
                  }
                  issues?.push(issue);
                }
                if (!issues) {
                  issues = result.issues;
                }
                if (info?.abortEarly) {
                  break;
                }
              } else {
                output[key] = result.output;
              }
            }
          }
          return issues ? getIssues2(issues) : executePipe2(
            output,
            pipe,
            info,
            "tuple"
          );
        }
      };
    }
    function tupleAsync(items, arg2, arg3, arg4) {
      const [rest, error, pipe] = getTupleArgs2(arg2, arg3, arg4);
      return {
        /**
         * The schema type.
         */
        schema: "tuple",
        /**
         * The tuple items and rest schema.
         */
        tuple: { items, rest },
        /**
         * Whether it's async.
         */
        async: true,
        /**
         * Parses unknown input based on its schema.
         *
         * @param input The input to be parsed.
         * @param info The parse info.
         *
         * @returns The parsed output.
         */
        async _parse(input, info) {
          if (!Array.isArray(input) || !rest && items.length !== input.length || rest && items.length > input.length) {
            return getSchemaIssues2(
              info,
              "type",
              "tuple",
              error || "Invalid type",
              input
            );
          }
          let issues;
          const output = [];
          await Promise.all([
            // Parse schema of each tuple item
            Promise.all(
              items.map(async (schema2, key) => {
                if (!(info?.abortEarly && issues)) {
                  const value2 = input[key];
                  const result = await schema2._parse(value2, info);
                  if (!(info?.abortEarly && issues)) {
                    if (result.issues) {
                      const pathItem = {
                        schema: "tuple",
                        input,
                        key,
                        value: value2
                      };
                      for (const issue of result.issues) {
                        if (issue.path) {
                          issue.path.unshift(pathItem);
                        } else {
                          issue.path = [pathItem];
                        }
                        issues?.push(issue);
                      }
                      if (!issues) {
                        issues = result.issues;
                      }
                      if (info?.abortEarly) {
                        throw null;
                      }
                    } else {
                      output[key] = result.output;
                    }
                  }
                }
              })
            ),
            // If necessary parse schema of each rest item
            rest && Promise.all(
              input.slice(items.length).map(async (value2, index) => {
                if (!(info?.abortEarly && issues)) {
                  const key = items.length + index;
                  const result = await rest._parse(value2, info);
                  if (!(info?.abortEarly && issues)) {
                    if (result.issues) {
                      const pathItem = {
                        schema: "tuple",
                        input,
                        key,
                        value: value2
                      };
                      for (const issue of result.issues) {
                        if (issue.path) {
                          issue.path.unshift(pathItem);
                        } else {
                          issue.path = [pathItem];
                        }
                        issues?.push(issue);
                      }
                      if (!issues) {
                        issues = result.issues;
                      }
                      if (info?.abortEarly) {
                        throw null;
                      }
                    } else {
                      output[key] = result.output;
                    }
                  }
                }
              })
            )
          ]).catch(() => null);
          return issues ? getIssues2(issues) : executePipeAsync(
            output,
            pipe,
            info,
            "tuple"
          );
        }
      };
    }
    function undefinedType(error) {
      return {
        /**
         * The schema type.
         */
        schema: "undefined",
        /**
         * Whether it's async.
         */
        async: false,
        /**
         * Parses unknown input based on its schema.
         *
         * @param input The input to be parsed.
         * @param info The parse info.
         *
         * @returns The parsed output.
         */
        _parse(input, info) {
          if (typeof input !== "undefined") {
            return getSchemaIssues2(
              info,
              "type",
              "undefined",
              error || "Invalid type",
              input
            );
          }
          return getOutput2(input);
        }
      };
    }
    function undefinedTypeAsync(error) {
      return {
        /**
         * The schema type.
         */
        schema: "undefined",
        /**
         * Whether it's async.
         */
        async: true,
        /**
         * Parses unknown input based on its schema.
         *
         * @param input The input to be parsed.
         * @param info The parse info.
         *
         * @returns The parsed output.
         */
        async _parse(input, info) {
          if (typeof input !== "undefined") {
            return getSchemaIssues2(
              info,
              "type",
              "undefined",
              error || "Invalid type",
              input
            );
          }
          return getOutput2(input);
        }
      };
    }
    function union2(union22, error) {
      return {
        /**
         * The schema type.
         */
        schema: "union",
        /**
         * The union schema.
         */
        union: union22,
        /**
         * Whether it's async.
         */
        async: false,
        /**
         * Parses unknown input based on its schema.
         *
         * @param input The input to be parsed.
         * @param info The parse info.
         *
         * @returns The parsed output.
         */
        _parse(input, info) {
          let issues;
          let output;
          for (const schema2 of union22) {
            const result = schema2._parse(input, info);
            if (result.issues) {
              if (issues) {
                for (const issue of result.issues) {
                  issues.push(issue);
                }
              } else {
                issues = result.issues;
              }
            } else {
              output = [result.output];
              break;
            }
          }
          return output ? getOutput2(output[0]) : getSchemaIssues2(
            info,
            "type",
            "union",
            error || "Invalid type",
            input,
            issues
          );
        }
      };
    }
    function unionAsync(union22, error) {
      return {
        /**
         * The schema type.
         */
        schema: "union",
        /**
         * The union schema.
         */
        union: union22,
        /**
         * Whether it's async.
         */
        async: true,
        /**
         * Parses unknown input based on its schema.
         *
         * @param input The input to be parsed.
         * @param info The parse info.
         *
         * @returns The parsed output.
         */
        async _parse(input, info) {
          let issues;
          let output;
          for (const schema2 of union22) {
            const result = await schema2._parse(input, info);
            if (result.issues) {
              if (issues) {
                for (const issue of result.issues) {
                  issues.push(issue);
                }
              } else {
                issues = result.issues;
              }
            } else {
              output = [result.output];
              break;
            }
          }
          return output ? getOutput2(output[0]) : getSchemaIssues2(
            info,
            "type",
            "union",
            error || "Invalid type",
            input,
            issues
          );
        }
      };
    }
    function unknown(pipe = []) {
      return {
        /**
         * The schema type.
         */
        schema: "unknown",
        /**
         * Whether it's async.
         */
        async: false,
        /**
         * Parses unknown input based on its schema.
         *
         * @param input The input to be parsed.
         * @param info The parse info.
         *
         * @returns The parsed output.
         */
        _parse(input, info) {
          return executePipe2(input, pipe, info, "unknown");
        }
      };
    }
    function unknownAsync(pipe = []) {
      return {
        /**
         * The schema type.
         */
        schema: "unknown",
        /**
         * Whether it's async.
         */
        async: true,
        /**
         * Parses unknown input based on its schema.
         *
         * @param input The input to be parsed.
         * @param info The parse info.
         *
         * @returns The parsed output.
         */
        async _parse(input, info) {
          return executePipeAsync(input, pipe, info, "unknown");
        }
      };
    }
    function voidType(error) {
      return {
        /**
         * The schema type.
         */
        schema: "void",
        /**
         * Whether it's async.
         */
        async: false,
        /**
         * Parses unknown input based on its schema.
         *
         * @param input The input to be parsed.
         * @param info The parse info.
         *
         * @returns The parsed output.
         */
        _parse(input, info) {
          if (typeof input !== "undefined") {
            return getSchemaIssues2(
              info,
              "type",
              "void",
              error || "Invalid type",
              input
            );
          }
          return getOutput2(input);
        }
      };
    }
    function voidTypeAsync(error) {
      return {
        /**
         * The schema type.
         */
        schema: "void",
        /**
         * Whether it's async.
         */
        async: true,
        /**
         * Parses unknown input based on its schema.
         *
         * @param input The input to be parsed.
         * @param info The parse info.
         *
         * @returns The parsed output.
         */
        async _parse(input, info) {
          if (typeof input !== "undefined") {
            return getSchemaIssues2(
              info,
              "type",
              "void",
              error || "Invalid type",
              input
            );
          }
          return getOutput2(input);
        }
      };
    }
    function keyof(schema2) {
      return enumType2(
        Object.keys(schema2.object)
      );
    }
    function merge(schemas, arg2, arg3) {
      const [error, pipe] = getDefaultArgs2(arg2, arg3);
      return object2(
        schemas.reduce(
          (object22, schemas2) => ({ ...object22, ...schemas2.object }),
          {}
        ),
        error,
        pipe
      );
    }
    function mergeAsync(schemas, arg2, arg3) {
      const [error, pipe] = getDefaultArgs2(arg2, arg3);
      return objectAsync(
        schemas.reduce(
          (object22, schemas2) => ({ ...object22, ...schemas2.object }),
          {}
        ),
        error,
        pipe
      );
    }
    function omit(schema2, keys, arg3, arg4) {
      const [error, pipe] = getDefaultArgs2(arg3, arg4);
      return object2(
        Object.entries(schema2.object).reduce(
          (object22, [key, schema22]) => keys.includes(key) ? object22 : { ...object22, [key]: schema22 },
          {}
        ),
        error,
        pipe
      );
    }
    function omitAsync(schema2, keys, arg3, arg4) {
      const [error, pipe] = getDefaultArgs2(arg3, arg4);
      return objectAsync(
        Object.entries(schema2.object).reduce(
          (object22, [key, schema22]) => keys.includes(key) ? object22 : { ...object22, [key]: schema22 },
          {}
        ),
        error,
        pipe
      );
    }
    function parse3(schema2, input, info) {
      const result = schema2._parse(input, info);
      if (result.issues) {
        throw new ValiError(result.issues);
      }
      return result.output;
    }
    async function parseAsync(schema2, input, info) {
      const result = await schema2._parse(input, info);
      if (result.issues) {
        throw new ValiError(result.issues);
      }
      return result.output;
    }
    function partial(schema2, arg3, arg4) {
      const [error, pipe] = getDefaultArgs2(arg3, arg4);
      return object2(
        Object.entries(schema2.object).reduce(
          (object22, [key, schema22]) => ({
            ...object22,
            [key]: optional2(schema22)
          }),
          {}
        ),
        error,
        // @ts-ignore FIXME: Remove line once bug in TS is fixed
        pipe
      );
    }
    function partialAsync(schema2, arg3, arg4) {
      const [error, pipe] = getDefaultArgs2(arg3, arg4);
      return objectAsync(
        Object.entries(schema2.object).reduce(
          (object22, [key, schema22]) => ({
            ...object22,
            [key]: optionalAsync(schema22)
          }),
          {}
        ),
        error,
        // @ts-ignore FIXME: Remove line once bug in TS is fixed
        pipe
      );
    }
    function passthrough(schema2) {
      return {
        ...schema2,
        /**
         * Parses unknown input based on its schema.
         *
         * @param input The input to be parsed.
         * @param info The parse info.
         *
         * @returns The parsed output.
         */
        _parse(input, info) {
          const result = schema2._parse(input, info);
          return !result.issues ? getOutput2({ ...input, ...result.output }) : result;
        }
      };
    }
    function passthroughAsync(schema2) {
      return {
        ...schema2,
        /**
         * Parses unknown input based on its schema.
         *
         * @param input The input to be parsed.
         * @param info The parse info.
         *
         * @returns The parsed output.
         */
        async _parse(input, info) {
          const result = await schema2._parse(input, info);
          return !result.issues ? getOutput2({ ...input, ...result.output }) : result;
        }
      };
    }
    function pick(schema2, keys, arg3, arg4) {
      const [error, pipe] = getDefaultArgs2(arg3, arg4);
      return object2(
        Object.entries(schema2.object).reduce(
          (object22, [key, schema22]) => keys.includes(key) ? { ...object22, [key]: schema22 } : object22,
          {}
        ),
        error,
        pipe
      );
    }
    function pickAsync(schema2, keys, arg3, arg4) {
      const [error, pipe] = getDefaultArgs2(arg3, arg4);
      return objectAsync(
        Object.entries(schema2.object).reduce(
          (object22, [key, schema22]) => keys.includes(key) ? { ...object22, [key]: schema22 } : object22,
          {}
        ),
        error,
        pipe
      );
    }
    function required(schema2, arg3, arg4) {
      const [error, pipe] = getDefaultArgs2(arg3, arg4);
      return object2(
        Object.entries(schema2.object).reduce(
          (object22, [key, schema22]) => ({
            ...object22,
            [key]: nonOptional(schema22)
          }),
          {}
        ),
        error,
        // @ts-ignore FIXME: Remove line once bug in TS is fixed
        pipe
      );
    }
    function requiredAsync(schema2, arg3, arg4) {
      const [error, pipe] = getDefaultArgs2(arg3, arg4);
      return objectAsync(
        Object.entries(schema2.object).reduce(
          (object22, [key, schema22]) => ({
            ...object22,
            [key]: nonOptionalAsync(schema22)
          }),
          {}
        ),
        error,
        // @ts-ignore FIXME: Remove line once bug in TS is fixed
        pipe
      );
    }
    function safeParse(schema2, input, info) {
      const result = schema2._parse(input, info);
      return result.issues ? {
        success: false,
        error: new ValiError(result.issues),
        issues: result.issues
      } : {
        success: true,
        data: result.output,
        output: result.output
      };
    }
    async function safeParseAsync(schema2, input, info) {
      const result = await schema2._parse(input, info);
      return result.issues ? {
        success: false,
        error: new ValiError(result.issues),
        issues: result.issues
      } : {
        success: true,
        data: result.output,
        output: result.output
      };
    }
    function strict(schema2, error) {
      return {
        ...schema2,
        /**
         * Parses unknown input based on its schema.
         *
         * @param input The input to be parsed.
         * @param info The parse info.
         *
         * @returns The parsed output.
         */
        _parse(input, info) {
          const result = schema2._parse(input, info);
          return !result.issues && Object.keys(input).some((key) => !(key in schema2.object)) ? getSchemaIssues2(
            info,
            "object",
            "strict",
            error || "Invalid keys",
            input
          ) : result;
        }
      };
    }
    function strictAsync(schema2, error) {
      return {
        ...schema2,
        /**
         * Parses unknown input based on its schema.
         *
         * @param input The input to be parsed.
         * @param info The parse info.
         *
         * @returns The parsed output.
         */
        async _parse(input, info) {
          const result = await schema2._parse(input, info);
          return !result.issues && Object.keys(input).some((key) => !(key in schema2.object)) ? getSchemaIssues2(
            info,
            "object",
            "strict",
            error || "Invalid keys",
            input
          ) : result;
        }
      };
    }
    function strip(schema2) {
      let cachedKeys;
      return {
        ...schema2,
        /**
         * Parses unknown input based on its schema.
         *
         * @param input The input to be parsed.
         * @param info The parse info.
         *
         * @returns The parsed output.
         */
        _parse(input, info) {
          const result = schema2._parse(input, info);
          if (result.issues) {
            return result;
          }
          cachedKeys = cachedKeys || Object.keys(schema2.object);
          const output = {};
          for (const key of cachedKeys) {
            output[key] = result.output[key];
          }
          return getOutput2(output);
        }
      };
    }
    function stripAsync(schema2) {
      let cachedKeys;
      return {
        ...schema2,
        /**
         * Parses unknown input based on its schema.
         *
         * @param input The input to be parsed.
         * @param info The parse info.
         *
         * @returns The parsed output.
         */
        async _parse(input, info) {
          const result = await schema2._parse(input, info);
          if (result.issues) {
            return result;
          }
          cachedKeys = cachedKeys || Object.keys(schema2.object);
          const output = {};
          for (const key of cachedKeys) {
            output[key] = result.output[key];
          }
          return getOutput2(output);
        }
      };
    }
    function transform(schema2, action, pipe) {
      return {
        ...schema2,
        /**
         * Parses unknown input based on its schema.
         *
         * @param input The input to be parsed.
         * @param info The parse info.
         *
         * @returns The parsed output.
         */
        _parse(input, info) {
          const result = schema2._parse(input, info);
          if (result.issues) {
            return result;
          }
          const output = action(result.output);
          return executePipe2(output, pipe, info, typeof output);
        }
      };
    }
    function transformAsync(schema2, action, pipe) {
      return {
        ...schema2,
        /**
         * Whether it's async.
         */
        async: true,
        /**
         * Parses unknown input based on its schema.
         *
         * @param input The input to be parsed.
         * @param info The parse info.
         *
         * @returns The parsed output.
         */
        async _parse(input, info) {
          const result = await schema2._parse(input, info);
          if (result.issues) {
            return result;
          }
          const output = await action(result.output);
          return executePipeAsync(output, pipe, info, typeof output);
        }
      };
    }
    function unwrap(schema2) {
      return schema2.wrapped;
    }
    function withDefault(schema2, value2) {
      return {
        ...schema2,
        /**
         * Parses unknown input based on its schema.
         *
         * @param input The input to be parsed.
         * @param info The parse info.
         *
         * @returns The parsed output.
         */
        _parse(input, info) {
          return schema2._parse(
            input === void 0 ? typeof value2 === "function" ? value2() : value2 : input,
            info
          );
        }
      };
    }
    var useDefault = withDefault;
    function toCustom(action) {
      return (input) => getOutput2(action(input));
    }
    function toCustomAsync(action) {
      return async (input) => getOutput2(await action(input));
    }
    function toLowerCase() {
      return (input) => getOutput2(input.toLocaleLowerCase());
    }
    function toMaxValue(requirement) {
      return (input) => getOutput2(input > requirement ? requirement : input);
    }
    function toMinValue(requirement) {
      return (input) => getOutput2(input < requirement ? requirement : input);
    }
    function toTrimmed() {
      return (input) => getOutput2(input.trim());
    }
    function toTrimmedEnd() {
      return (input) => getOutput2(input.trimEnd());
    }
    function toTrimmedStart() {
      return (input) => getOutput2(input.trimStart());
    }
    function toUpperCase() {
      return (input) => getOutput2(input.toUpperCase());
    }
    function bytes(requirement, error) {
      return (input) => new TextEncoder().encode(input).length !== requirement ? getPipeIssues("bytes", error || "Invalid byte length", input) : getOutput2(input);
    }
    function cuid2(error) {
      return (input) => !/^[a-z][a-z0-9]*$/.test(input) ? getPipeIssues("cuid2", error || "Invalid cuid2", input) : getOutput2(input);
    }
    function custom(requirement, error) {
      return (input) => !requirement(input) ? getPipeIssues("custom", error || "Invalid input", input) : getOutput2(input);
    }
    function customAsync(requirement, error) {
      return async (input) => !await requirement(input) ? getPipeIssues("custom", error || "Invalid input", input) : getOutput2(input);
    }
    function email(error) {
      return (input) => !/^[\w+-]+(?:\.[\w+-]+)*@[\da-z]+(?:[.-][\da-z]+)*\.[a-z]{2,}$/i.test(input) ? getPipeIssues("email", error || "Invalid email", input) : getOutput2(input);
    }
    function emoji(error) {
      return (input) => !/^(\p{Extended_Pictographic}|\p{Emoji_Component})+$/u.test(input) ? getPipeIssues("emoji", error || "Invalid emoji", input) : getOutput2(input);
    }
    function endsWith(requirement, error) {
      return (input) => !input.endsWith(requirement) ? getPipeIssues("ends_with", error || "Invalid end", input) : getOutput2(input);
    }
    function equal(requirement, error) {
      return (input) => input !== requirement ? getPipeIssues("equal", error || "Invalid input", input) : getOutput2(input);
    }
    function excludes(requirement, error) {
      return (input) => input.includes(requirement) ? getPipeIssues("excludes", error || "Invalid content", input) : getOutput2(input);
    }
    function finite(error) {
      return (input) => !Number.isFinite(input) ? getPipeIssues("finite", error || "Invalid finite number", input) : getOutput2(input);
    }
    function imei(error) {
      return (input) => !/^\d{2}[ |/|-]?\d{6}[ |/|-]?\d{6}[ |/|-]?\d$/.test(input) || !isLuhnAlgo(input) ? getPipeIssues("imei", error || "Invalid IMEI", input) : getOutput2(input);
    }
    function includes2(requirement, error) {
      return (input) => !input.includes(requirement) ? getPipeIssues("includes", error || "Invalid content", input) : getOutput2(input);
    }
    function integer(error) {
      return (input) => !Number.isInteger(input) ? getPipeIssues("integer", error || "Invalid integer", input) : getOutput2(input);
    }
    function ip(error) {
      return (input) => !/^((25[0-5]|(2[0-4]|1\d|[1-9]|)\d)\.?\b){4}$/.test(input) && !/^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/.test(
        input
      ) ? getPipeIssues("ip", error || "Invalid IP", input) : getOutput2(input);
    }
    function ipv4(error) {
      return (input) => !/^((25[0-5]|(2[0-4]|1\d|[1-9]|)\d)\.?\b){4}$/.test(input) ? getPipeIssues("ipv4", error || "Invalid IP v4", input) : getOutput2(input);
    }
    function ipv6(error) {
      return (input) => !/^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/.test(
        input
      ) ? getPipeIssues("ipv6", error || "Invalid IP v6", input) : getOutput2(input);
    }
    function isoDate(error) {
      return (input) => !/^\d{4}-(0[1-9]|1[0-2])-([12]\d|0[1-9]|3[01])$/.test(input) ? getPipeIssues("iso_date", error || "Invalid date", input) : getOutput2(input);
    }
    function isoDateTime(error) {
      return (input) => !/^\d{4}-(0[1-9]|1[0-2])-([12]\d|0[1-9]|3[01])T(0[0-9]|1\d|2[0-3]):[0-5]\d$/.test(
        input
      ) ? getPipeIssues("iso_date_time", error || "Invalid datetime", input) : getOutput2(input);
    }
    function isoTime(error) {
      return (input) => !/^(0[0-9]|1\d|2[0-3]):[0-5]\d$/.test(input) ? getPipeIssues("iso_time", error || "Invalid time", input) : getOutput2(input);
    }
    function isoTimeSecond(error) {
      return (input) => !/^(0[0-9]|1\d|2[0-3]):[0-5]\d:[0-5]\d$/.test(input) ? getPipeIssues("iso_time_second", error || "Invalid time", input) : getOutput2(input);
    }
    function isoTimestamp(error) {
      return (input) => !/^\d{4}-(0[1-9]|1[0-2])-([12]\d|0[1-9]|3[01])T(0[0-9]|1\d|2[0-3]):[0-5]\d:[0-5]\d\.\d{3}Z$/.test(
        input
      ) ? getPipeIssues("iso_timestamp", error || "Invalid timestamp", input) : getOutput2(input);
    }
    function isoWeek(error) {
      return (input) => !/^\d{4}-W(0[1-9]|[1-4]\d|5[0-3])$/.test(input) ? getPipeIssues("iso_week", error || "Invalid week", input) : getOutput2(input);
    }
    function length(requirement, error) {
      return (input) => input.length !== requirement ? getPipeIssues("length", error || "Invalid length", input) : getOutput2(input);
    }
    function maxBytes(requirement, error) {
      return (input) => new TextEncoder().encode(input).length > requirement ? getPipeIssues("max_bytes", error || "Invalid byte length", input) : getOutput2(input);
    }
    function maxLength(requirement, error) {
      return (input) => input.length > requirement ? getPipeIssues("max_length", error || "Invalid length", input) : getOutput2(input);
    }
    function maxSize(requirement, error) {
      return (input) => input.size > requirement ? getPipeIssues("max_size", error || "Invalid size", input) : getOutput2(input);
    }
    function maxValue(requirement, error) {
      return (input) => input > requirement ? getPipeIssues("max_value", error || "Invalid value", input) : getOutput2(input);
    }
    var maxRange = maxValue;
    function minBytes(requirement, error) {
      return (input) => new TextEncoder().encode(input).length < requirement ? getPipeIssues("min_bytes", error || "Invalid byte length", input) : getOutput2(input);
    }
    function mimeType(requirement, error) {
      return (input) => !requirement.includes(input.type) ? getPipeIssues("mime_type", error || "Invalid MIME type", input) : getOutput2(input);
    }
    function minLength(requirement, error) {
      return (input) => input.length < requirement ? getPipeIssues("min_length", error || "Invalid length", input) : getOutput2(input);
    }
    function minSize(requirement, error) {
      return (input) => input.size < requirement ? getPipeIssues("min_size", error || "Invalid size", input) : getOutput2(input);
    }
    function minValue(requirement, error) {
      return (input) => input < requirement ? getPipeIssues("min_value", error || "Invalid value", input) : getOutput2(input);
    }
    var minRange = minValue;
    function multipleOf(requirement, error) {
      return (input) => input % requirement !== 0 ? getPipeIssues("multiple_of", error || "Invalid multiple", input) : getOutput2(input);
    }
    function notBytes(requirement, error) {
      return (input) => new TextEncoder().encode(input).length === requirement ? getPipeIssues("not_bytes", error || "Invalid byte length", input) : getOutput2(input);
    }
    function notLength(requirement, error) {
      return (input) => input.length === requirement ? getPipeIssues("not_length", error || "Invalid length", input) : getOutput2(input);
    }
    function notSize(requirement, error) {
      return (input) => input.size === requirement ? getPipeIssues("not_size", error || "Invalid size", input) : getOutput2(input);
    }
    function notValue(requirement, error) {
      return (input) => input === requirement ? getPipeIssues("not_value", error || "Invalid value", input) : getOutput2(input);
    }
    function regex(requirement, error) {
      return (input) => !requirement.test(input) ? getPipeIssues("regex", error || "Invalid regex", input) : getOutput2(input);
    }
    function safeInteger(error) {
      return (input) => !Number.isSafeInteger(input) ? getPipeIssues("safe_integer", error || "Invalid safe integer", input) : getOutput2(input);
    }
    function size(requirement, error) {
      return (input) => input.size !== requirement ? getPipeIssues("size", error || "Invalid size", input) : getOutput2(input);
    }
    function startsWith(requirement, error) {
      return (input) => !input.startsWith(requirement) ? getPipeIssues("starts_with", error || "Invalid start", input) : getOutput2(input);
    }
    function ulid(error) {
      return (input) => !/^[0-9A-HJKMNPQ-TV-Z]{26}$/i.test(input) ? getPipeIssues("ulid", error || "Invalid ULID", input) : getOutput2(input);
    }
    function url(error) {
      return (input) => {
        try {
          new URL(input);
          return getOutput2(input);
        } catch (_) {
          return getPipeIssues("url", error || "Invalid URL", input);
        }
      };
    }
    function uuid(error) {
      return (input) => !/^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i.test(
        input
      ) ? getPipeIssues("uuid", error || "Invalid UUID", input) : getOutput2(input);
    }
    function value(requirement, error) {
      return (input) => input !== requirement ? getPipeIssues("value", error || "Invalid value", input) : getOutput2(input);
    }
  }
});

// node_modules/.pnpm/@hono+valibot-validator@0.2.0_hono@3.8.1_valibot@0.19.0/node_modules/@hono/valibot-validator/dist/cjs/index.js
var require_cjs = __commonJS({
  "node_modules/.pnpm/@hono+valibot-validator@0.2.0_hono@3.8.1_valibot@0.19.0/node_modules/@hono/valibot-validator/dist/cjs/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.vValidator = void 0;
    var validator_1 = require_validator2();
    var valibot_1 = require_dist();
    var vValidator2 = (target, schema2, hook) => (0, validator_1.validator)(target, (value, c) => {
      const result = (0, valibot_1.safeParse)(schema2, value);
      if (hook) {
        const hookResult = hook(result, c);
        if (hookResult instanceof Response || hookResult instanceof Promise) {
          return hookResult;
        }
      }
      if (!result.success) {
        return c.json(result, 400);
      }
      const data = result.output;
      return data;
    });
    exports.vValidator = vValidator2;
  }
});

// src/server.ts
var server_exports = {};
__export(server_exports, {
  prepareServer: () => prepareServer
});
module.exports = __toCommonJS(server_exports);

// node_modules/.pnpm/hono@3.8.1/node_modules/hono/dist/types.js
var FetchEventLike = class {
};
var FetchEvent = class extends FetchEventLike {
};

// node_modules/.pnpm/hono@3.8.1/node_modules/hono/dist/utils/url.js
var splitPath = (path) => {
  const paths = path.split("/");
  if (paths[0] === "") {
    paths.shift();
  }
  return paths;
};
var splitRoutingPath = (path) => {
  const groups = [];
  for (let i = 0; ; ) {
    let replaced = false;
    path = path.replace(/\{[^}]+\}/g, (m) => {
      const mark = `@\\${i}`;
      groups[i] = [mark, m];
      i++;
      replaced = true;
      return mark;
    });
    if (!replaced) {
      break;
    }
  }
  const paths = path.split("/");
  if (paths[0] === "") {
    paths.shift();
  }
  for (let i = groups.length - 1; i >= 0; i--) {
    const [mark] = groups[i];
    for (let j = paths.length - 1; j >= 0; j--) {
      if (paths[j].indexOf(mark) !== -1) {
        paths[j] = paths[j].replace(mark, groups[i][1]);
        break;
      }
    }
  }
  return paths;
};
var patternCache = {};
var getPattern = (label) => {
  if (label === "*") {
    return "*";
  }
  const match = label.match(/^\:([^\{\}]+)(?:\{(.+)\})?$/);
  if (match) {
    if (!patternCache[label]) {
      if (match[2]) {
        patternCache[label] = [label, match[1], new RegExp("^" + match[2] + "$")];
      } else {
        patternCache[label] = [label, match[1], true];
      }
    }
    return patternCache[label];
  }
  return null;
};
var getPath = (request) => {
  const match = request.url.match(/^https?:\/\/[^/]+(\/[^?]*)/);
  return match ? match[1] : "";
};
var getQueryStrings = (url) => {
  const queryIndex = url.indexOf("?", 8);
  return queryIndex === -1 ? "" : "?" + url.slice(queryIndex + 1);
};
var getPathNoStrict = (request) => {
  const result = getPath(request);
  return result.length > 1 && result[result.length - 1] === "/" ? result.slice(0, -1) : result;
};
var mergePath = (...paths) => {
  let p = "";
  let endsWithSlash = false;
  for (let path of paths) {
    if (p[p.length - 1] === "/") {
      p = p.slice(0, -1);
      endsWithSlash = true;
    }
    if (path[0] !== "/") {
      path = `/${path}`;
    }
    if (path === "/" && endsWithSlash) {
      p = `${p}/`;
    } else if (path !== "/") {
      p = `${p}${path}`;
    }
    if (path === "/" && p === "") {
      p = "/";
    }
  }
  return p;
};
var checkOptionalParameter = (path) => {
  const match = path.match(/^(.+|)(\/\:[^\/]+)\?$/);
  if (!match)
    return null;
  const base = match[1];
  const optional2 = base + match[2];
  return [base === "" ? "/" : base.replace(/\/$/, ""), optional2];
};
var _decodeURI = (value) => {
  if (!/[%+]/.test(value)) {
    return value;
  }
  if (value.indexOf("+") !== -1) {
    value = value.replace(/\+/g, " ");
  }
  return /%/.test(value) ? decodeURIComponent_(value) : value;
};
var _getQueryParam = (url, key, multiple) => {
  let encoded;
  if (!multiple && key && !/[%+]/.test(key)) {
    let keyIndex2 = url.indexOf(`?${key}`, 8);
    if (keyIndex2 === -1) {
      keyIndex2 = url.indexOf(`&${key}`, 8);
    }
    while (keyIndex2 !== -1) {
      const trailingKeyCode = url.charCodeAt(keyIndex2 + key.length + 1);
      if (trailingKeyCode === 61) {
        const valueIndex = keyIndex2 + key.length + 2;
        const endIndex = url.indexOf("&", valueIndex);
        return _decodeURI(url.slice(valueIndex, endIndex === -1 ? void 0 : endIndex));
      } else if (trailingKeyCode == 38 || isNaN(trailingKeyCode)) {
        return "";
      }
      keyIndex2 = url.indexOf(`&${key}`, keyIndex2 + 1);
    }
    encoded = /[%+]/.test(url);
    if (!encoded) {
      return void 0;
    }
  }
  const results = {};
  encoded ?? (encoded = /[%+]/.test(url));
  let keyIndex = url.indexOf("?", 8);
  while (keyIndex !== -1) {
    const nextKeyIndex = url.indexOf("&", keyIndex + 1);
    let valueIndex = url.indexOf("=", keyIndex);
    if (valueIndex > nextKeyIndex && nextKeyIndex !== -1) {
      valueIndex = -1;
    }
    let name = url.slice(
      keyIndex + 1,
      valueIndex === -1 ? nextKeyIndex === -1 ? void 0 : nextKeyIndex : valueIndex
    );
    if (encoded) {
      name = _decodeURI(name);
    }
    keyIndex = nextKeyIndex;
    if (name === "") {
      continue;
    }
    let value;
    if (valueIndex === -1) {
      value = "";
    } else {
      value = url.slice(valueIndex + 1, nextKeyIndex === -1 ? void 0 : nextKeyIndex);
      if (encoded) {
        value = _decodeURI(value);
      }
    }
    if (multiple) {
      ;
      (results[name] ?? (results[name] = [])).push(value);
    } else {
      results[name] ?? (results[name] = value);
    }
  }
  return key ? results[key] : results;
};
var getQueryParam = _getQueryParam;
var getQueryParams = (url, key) => {
  return _getQueryParam(url, key, true);
};
var decodeURIComponent_ = decodeURIComponent;

// node_modules/.pnpm/hono@3.8.1/node_modules/hono/dist/utils/cookie.js
var validCookieNameRegEx = /^[\w!#$%&'*.^`|~+-]+$/;
var validCookieValueRegEx = /^[ !#-:<-[\]-~]*$/;
var parse = (cookie, name) => {
  const pairs = cookie.trim().split(";");
  return pairs.reduce((parsedCookie, pairStr) => {
    pairStr = pairStr.trim();
    const valueStartPos = pairStr.indexOf("=");
    if (valueStartPos === -1)
      return parsedCookie;
    const cookieName = pairStr.substring(0, valueStartPos).trim();
    if (name && name !== cookieName || !validCookieNameRegEx.test(cookieName))
      return parsedCookie;
    let cookieValue = pairStr.substring(valueStartPos + 1).trim();
    if (cookieValue.startsWith('"') && cookieValue.endsWith('"'))
      cookieValue = cookieValue.slice(1, -1);
    if (validCookieValueRegEx.test(cookieValue))
      parsedCookie[cookieName] = decodeURIComponent_(cookieValue);
    return parsedCookie;
  }, {});
};
var _serialize = (name, value, opt = {}) => {
  let cookie = `${name}=${value}`;
  if (opt && typeof opt.maxAge === "number" && opt.maxAge >= 0) {
    cookie += `; Max-Age=${Math.floor(opt.maxAge)}`;
  }
  if (opt.domain) {
    cookie += `; Domain=${opt.domain}`;
  }
  if (opt.path) {
    cookie += `; Path=${opt.path}`;
  }
  if (opt.expires) {
    cookie += `; Expires=${opt.expires.toUTCString()}`;
  }
  if (opt.httpOnly) {
    cookie += "; HttpOnly";
  }
  if (opt.secure) {
    cookie += "; Secure";
  }
  if (opt.sameSite) {
    cookie += `; SameSite=${opt.sameSite}`;
  }
  if (opt.partitioned) {
    cookie += "; Partitioned";
  }
  return cookie;
};
var serialize = (name, value, opt = {}) => {
  value = encodeURIComponent(value);
  return _serialize(name, value, opt);
};

// node_modules/.pnpm/hono@3.8.1/node_modules/hono/dist/utils/stream.js
var StreamingApi = class {
  constructor(writable) {
    this.writable = writable;
    this.writer = writable.getWriter();
    this.encoder = new TextEncoder();
  }
  async write(input) {
    try {
      if (typeof input === "string") {
        input = this.encoder.encode(input);
      }
      await this.writer.write(input);
    } catch (e) {
    }
    return this;
  }
  async writeln(input) {
    await this.write(input + "\n");
    return this;
  }
  sleep(ms) {
    return new Promise((res) => setTimeout(res, ms));
  }
  async close() {
    try {
      await this.writer.close();
    } catch (e) {
    }
  }
  async pipe(body) {
    this.writer.releaseLock();
    await body.pipeTo(this.writable, { preventClose: true });
    this.writer = this.writable.getWriter();
  }
};

// node_modules/.pnpm/hono@3.8.1/node_modules/hono/dist/context.js
var TEXT_PLAIN = "text/plain; charset=UTF-8";
var Context = class {
  constructor(req, options) {
    this.env = {};
    this._var = {};
    this.finalized = false;
    this.error = void 0;
    this._status = 200;
    this._h = void 0;
    this._pH = void 0;
    this._init = true;
    this._renderer = (content) => this.html(content);
    this.notFoundHandler = () => new Response();
    this.render = (...args) => this._renderer(...args);
    this.setRenderer = (renderer) => {
      this._renderer = renderer;
    };
    this.header = (name, value, options2) => {
      if (value === void 0) {
        if (this._h) {
          this._h.delete(name);
        } else if (this._pH) {
          delete this._pH[name.toLocaleLowerCase()];
        }
        if (this.finalized) {
          this.res.headers.delete(name);
        }
        return;
      }
      if (options2?.append) {
        if (!this._h) {
          this._init = false;
          this._h = new Headers(this._pH);
          this._pH = {};
        }
        this._h.append(name, value);
      } else {
        if (this._h) {
          this._h.set(name, value);
        } else {
          this._pH ?? (this._pH = {});
          this._pH[name.toLowerCase()] = value;
        }
      }
      if (this.finalized) {
        if (options2?.append) {
          this.res.headers.append(name, value);
        } else {
          this.res.headers.set(name, value);
        }
      }
    };
    this.status = (status) => {
      this._status = status;
    };
    this.set = (key, value) => {
      this._var ?? (this._var = {});
      this._var[key] = value;
    };
    this.get = (key) => {
      return this._var ? this._var[key] : void 0;
    };
    this.newResponse = (data, arg, headers) => {
      if (this._init && !headers && !arg && this._status === 200) {
        return new Response(data, {
          headers: this._pH
        });
      }
      if (arg && typeof arg !== "number") {
        const res = new Response(data, arg);
        const contentType = this._pH?.["content-type"];
        if (contentType) {
          res.headers.set("content-type", contentType);
        }
        return res;
      }
      const status = arg ?? this._status;
      this._pH ?? (this._pH = {});
      this._h ?? (this._h = new Headers());
      for (const [k, v] of Object.entries(this._pH)) {
        this._h.set(k, v);
      }
      if (this._res) {
        this._res.headers.forEach((v, k) => {
          this._h?.set(k, v);
        });
        for (const [k, v] of Object.entries(this._pH)) {
          this._h.set(k, v);
        }
      }
      headers ?? (headers = {});
      for (const [k, v] of Object.entries(headers)) {
        if (typeof v === "string") {
          this._h.set(k, v);
        } else {
          this._h.delete(k);
          for (const v2 of v) {
            this._h.append(k, v2);
          }
        }
      }
      return new Response(data, {
        status,
        headers: this._h
      });
    };
    this.body = (data, arg, headers) => {
      return typeof arg === "number" ? this.newResponse(data, arg, headers) : this.newResponse(data, arg);
    };
    this.text = (text, arg, headers) => {
      if (!this._pH) {
        if (this._init && !headers && !arg) {
          return new Response(text);
        }
        this._pH = {};
      }
      if (this._pH["content-type"]) {
        this._pH["content-type"] = TEXT_PLAIN;
      }
      return typeof arg === "number" ? this.newResponse(text, arg, headers) : this.newResponse(text, arg);
    };
    this.json = (object2, arg, headers) => {
      const body = JSON.stringify(object2);
      this._pH ?? (this._pH = {});
      this._pH["content-type"] = "application/json; charset=UTF-8";
      return typeof arg === "number" ? this.newResponse(body, arg, headers) : this.newResponse(body, arg);
    };
    this.jsonT = (object2, arg, headers) => {
      const response = typeof arg === "number" ? this.json(object2, arg, headers) : this.json(object2, arg);
      return {
        response,
        data: object2,
        format: "json",
        status: response.status
      };
    };
    this.html = (html, arg, headers) => {
      this._pH ?? (this._pH = {});
      this._pH["content-type"] = "text/html; charset=UTF-8";
      return typeof arg === "number" ? this.newResponse(html, arg, headers) : this.newResponse(html, arg);
    };
    this.redirect = (location, status = 302) => {
      this._h ?? (this._h = new Headers());
      this._h.set("Location", location);
      return this.newResponse(null, status);
    };
    this.streamText = (cb, arg, headers) => {
      headers ?? (headers = {});
      this.header("content-type", TEXT_PLAIN);
      this.header("x-content-type-options", "nosniff");
      this.header("transfer-encoding", "chunked");
      return this.stream(cb, arg, headers);
    };
    this.stream = (cb, arg, headers) => {
      const { readable, writable } = new TransformStream();
      const stream = new StreamingApi(writable);
      cb(stream).finally(() => stream.close());
      return typeof arg === "number" ? this.newResponse(readable, arg, headers) : this.newResponse(readable, arg);
    };
    this.cookie = (name, value, opt) => {
      const cookie = serialize(name, value, opt);
      this.header("set-cookie", cookie, { append: true });
    };
    this.notFound = () => {
      return this.notFoundHandler(this);
    };
    this.req = req;
    if (options) {
      this._exCtx = options.executionCtx;
      this.env = options.env;
      if (options.notFoundHandler) {
        this.notFoundHandler = options.notFoundHandler;
      }
    }
  }
  get event() {
    if (this._exCtx instanceof FetchEvent) {
      return this._exCtx;
    } else {
      throw Error("This context has no FetchEvent");
    }
  }
  get executionCtx() {
    if (this._exCtx) {
      return this._exCtx;
    } else {
      throw Error("This context has no ExecutionContext");
    }
  }
  get res() {
    this._init = false;
    return this._res || (this._res = new Response("404 Not Found", { status: 404 }));
  }
  set res(_res) {
    this._init = false;
    if (this._res && _res) {
      this._res.headers.delete("content-type");
      this._res.headers.forEach((v, k) => {
        _res.headers.set(k, v);
      });
    }
    this._res = _res;
    this.finalized = true;
  }
  get var() {
    return { ...this._var };
  }
  get runtime() {
    const global2 = globalThis;
    if (global2?.Deno !== void 0) {
      return "deno";
    }
    if (global2?.Bun !== void 0) {
      return "bun";
    }
    if (typeof global2?.WebSocketPair === "function") {
      return "workerd";
    }
    if (typeof global2?.EdgeRuntime === "string") {
      return "edge-light";
    }
    if (global2?.fastly !== void 0) {
      return "fastly";
    }
    if (global2?.__lagon__ !== void 0) {
      return "lagon";
    }
    if (global2?.process?.release?.name === "node") {
      return "node";
    }
    return "other";
  }
};

// node_modules/.pnpm/hono@3.8.1/node_modules/hono/dist/compose.js
var compose = (middleware, onError, onNotFound) => {
  return (context, next) => {
    let index = -1;
    return dispatch(0);
    function dispatch(i) {
      if (i <= index) {
        throw new Error("next() called multiple times");
      }
      index = i;
      let res;
      let isError2 = false;
      let handler;
      if (middleware[i]) {
        handler = middleware[i][0];
        if (context instanceof Context) {
          context.req.setParams(middleware[i][1]);
        }
      } else {
        handler = i === middleware.length && next || void 0;
      }
      if (!handler) {
        if (context instanceof Context && context.finalized === false && onNotFound) {
          res = onNotFound(context);
        }
      } else {
        try {
          res = handler(context, () => {
            const dispatchRes = dispatch(i + 1);
            return dispatchRes instanceof Promise ? dispatchRes : Promise.resolve(dispatchRes);
          });
        } catch (err) {
          if (err instanceof Error && context instanceof Context && onError) {
            context.error = err;
            res = onError(err, context);
            isError2 = true;
          } else {
            throw err;
          }
        }
      }
      if (!(res instanceof Promise)) {
        if (res !== void 0 && "response" in res) {
          res = res["response"];
        }
        if (res && (context.finalized === false || isError2)) {
          context.res = res;
        }
        return context;
      } else {
        return res.then((res2) => {
          if (res2 !== void 0 && "response" in res2) {
            res2 = res2["response"];
          }
          if (res2 && context.finalized === false) {
            context.res = res2;
          }
          return context;
        }).catch(async (err) => {
          if (err instanceof Error && context instanceof Context && onError) {
            context.error = err;
            context.res = await onError(err, context);
            return context;
          }
          throw err;
        });
      }
    }
  };
};

// node_modules/.pnpm/hono@3.8.1/node_modules/hono/dist/http-exception.js
var HTTPException = class extends Error {
  constructor(status = 500, options) {
    super(options?.message);
    this.res = options?.res;
    this.status = status;
  }
  getResponse() {
    if (this.res) {
      return this.res;
    }
    return new Response(this.message, {
      status: this.status
    });
  }
};

// node_modules/.pnpm/hono@3.8.1/node_modules/hono/dist/utils/body.js
var isArrayField = (value) => {
  return Array.isArray(value);
};
var parseBody = async (request, options = {
  all: false
}) => {
  let body = {};
  const contentType = request.headers.get("Content-Type");
  if (contentType && (contentType.startsWith("multipart/form-data") || contentType.startsWith("application/x-www-form-urlencoded"))) {
    const formData = await request.formData();
    if (formData) {
      const form = {};
      formData.forEach((value, key) => {
        const shouldParseAllValues = options.all || key.slice(-2) === "[]";
        if (!shouldParseAllValues) {
          form[key] = value;
          return;
        }
        if (form[key] && isArrayField(form[key])) {
          ;
          form[key].push(value);
          return;
        }
        if (form[key]) {
          form[key] = [form[key], value];
          return;
        }
        form[key] = value;
      });
      body = form;
    }
  }
  return body;
};

// node_modules/.pnpm/hono@3.8.1/node_modules/hono/dist/request.js
var HonoRequest = class {
  constructor(request, path = "/", paramStash = []) {
    this._p = {};
    this.bodyCache = {};
    this.cachedBody = (key) => {
      const { bodyCache, raw } = this;
      const cachedBody = bodyCache[key];
      if (cachedBody)
        return cachedBody;
      if (bodyCache.arrayBuffer) {
        return (async () => {
          return await new Response(bodyCache.arrayBuffer)[key]();
        })();
      }
      return bodyCache[key] = raw[key]();
    };
    this.raw = request;
    this.path = path;
    this._s = paramStash;
    this.vData = {};
  }
  setParams(params) {
    this._p = params;
  }
  param(key) {
    if (this._s) {
      if (key) {
        const param = this._s[this._p[key]] ?? this._p[key];
        return param ? /\%/.test(param) ? decodeURIComponent_(param) : param : void 0;
      } else {
        const decoded = {};
        const keys = Object.keys(this._p);
        for (let i = 0, len = keys.length; i < len; i++) {
          const key2 = keys[i];
          const value = this._s[this._p[key2]] ?? this._p[key2];
          if (value && typeof value === "string") {
            decoded[key2] = /\%/.test(value) ? decodeURIComponent_(value) : value;
          }
        }
        return decoded;
      }
    }
    return null;
  }
  query(key) {
    return getQueryParam(this.url, key);
  }
  queries(key) {
    return getQueryParams(this.url, key);
  }
  header(name) {
    if (name)
      return this.raw.headers.get(name.toLowerCase()) ?? void 0;
    const headerData = {};
    this.raw.headers.forEach((value, key) => {
      headerData[key] = value;
    });
    return headerData;
  }
  cookie(key) {
    const cookie = this.raw.headers.get("Cookie");
    if (!cookie)
      return;
    const obj = parse(cookie);
    if (key) {
      const value = obj[key];
      return value;
    } else {
      return obj;
    }
  }
  async parseBody(options) {
    if (this.bodyCache.parsedBody)
      return this.bodyCache.parsedBody;
    const parsedBody = await parseBody(this, options);
    this.bodyCache.parsedBody = parsedBody;
    return parsedBody;
  }
  json() {
    return this.cachedBody("json");
  }
  text() {
    return this.cachedBody("text");
  }
  arrayBuffer() {
    return this.cachedBody("arrayBuffer");
  }
  blob() {
    return this.cachedBody("blob");
  }
  formData() {
    return this.cachedBody("formData");
  }
  addValidatedData(target, data) {
    this.vData[target] = data;
  }
  valid(target) {
    return this.vData[target];
  }
  get url() {
    return this.raw.url;
  }
  get method() {
    return this.raw.method;
  }
  get headers() {
    return this.raw.headers;
  }
  get body() {
    return this.raw.body;
  }
  get bodyUsed() {
    return this.raw.bodyUsed;
  }
  get integrity() {
    return this.raw.integrity;
  }
  get keepalive() {
    return this.raw.keepalive;
  }
  get referrer() {
    return this.raw.referrer;
  }
  get signal() {
    return this.raw.signal;
  }
};

// node_modules/.pnpm/hono@3.8.1/node_modules/hono/dist/router.js
var METHOD_NAME_ALL = "ALL";
var METHOD_NAME_ALL_LOWERCASE = "all";
var METHODS = ["get", "post", "put", "delete", "options", "patch"];
var UnsupportedPathError = class extends Error {
};

// node_modules/.pnpm/hono@3.8.1/node_modules/hono/dist/hono-base.js
function defineDynamicClass() {
  return class {
  };
}
var notFoundHandler = (c) => {
  return c.text("404 Not Found", 404);
};
var errorHandler = (err, c) => {
  if (err instanceof HTTPException) {
    return err.getResponse();
  }
  console.trace(err);
  const message = "Internal Server Error";
  return c.text(message, 500);
};
var Hono = class extends defineDynamicClass() {
  constructor(options = {}) {
    super();
    this._basePath = "/";
    this.path = "/";
    this.routes = [];
    this.notFoundHandler = notFoundHandler;
    this.errorHandler = errorHandler;
    this.head = () => {
      console.warn("`app.head()` is no longer used. `app.get()` implicitly handles the HEAD method.");
      return this;
    };
    this.handleEvent = (event) => {
      return this.dispatch(event.request, event, void 0, event.request.method);
    };
    this.fetch = (request, Env2, executionCtx) => {
      return this.dispatch(request, executionCtx, Env2, request.method);
    };
    this.request = (input, requestInit, Env2, executionCtx) => {
      if (input instanceof Request) {
        if (requestInit !== void 0) {
          input = new Request(input, requestInit);
        }
        return this.fetch(input, Env2, executionCtx);
      }
      input = input.toString();
      const path = /^https?:\/\//.test(input) ? input : `http://localhost${mergePath("/", input)}`;
      const req = new Request(path, requestInit);
      return this.fetch(req, Env2, executionCtx);
    };
    this.fire = () => {
      addEventListener("fetch", (event) => {
        event.respondWith(this.dispatch(event.request, event, void 0, event.request.method));
      });
    };
    const allMethods = [...METHODS, METHOD_NAME_ALL_LOWERCASE];
    allMethods.map((method) => {
      this[method] = (args1, ...args) => {
        if (typeof args1 === "string") {
          this.path = args1;
        } else {
          this.addRoute(method, this.path, args1);
        }
        args.map((handler) => {
          if (typeof handler !== "string") {
            this.addRoute(method, this.path, handler);
          }
        });
        return this;
      };
    });
    this.on = (method, path, ...handlers) => {
      if (!method)
        return this;
      this.path = path;
      for (const m of [method].flat()) {
        handlers.map((handler) => {
          this.addRoute(m.toUpperCase(), this.path, handler);
        });
      }
      return this;
    };
    this.use = (arg1, ...handlers) => {
      if (typeof arg1 === "string") {
        this.path = arg1;
      } else {
        handlers.unshift(arg1);
      }
      handlers.map((handler) => {
        this.addRoute(METHOD_NAME_ALL, this.path, handler);
      });
      return this;
    };
    const strict = options.strict ?? true;
    delete options.strict;
    Object.assign(this, options);
    this.getPath = strict ? options.getPath ?? getPath : getPathNoStrict;
  }
  clone() {
    const clone = new Hono({
      router: this.router,
      getPath: this.getPath
    });
    clone.routes = this.routes;
    return clone;
  }
  route(path, app) {
    const subApp = this.basePath(path);
    if (!app) {
      return subApp;
    }
    app.routes.map((r) => {
      const handler = app.errorHandler === errorHandler ? r.handler : async (c, next) => (await compose([], app.errorHandler)(c, () => r.handler(c, next))).res;
      subApp.addRoute(r.method, r.path, handler);
    });
    return this;
  }
  basePath(path) {
    const subApp = this.clone();
    subApp._basePath = mergePath(this._basePath, path);
    return subApp;
  }
  onError(handler) {
    this.errorHandler = handler;
    return this;
  }
  notFound(handler) {
    this.notFoundHandler = handler;
    return this;
  }
  showRoutes() {
    const length = 8;
    this.routes.map((route) => {
      console.log(
        `\x1B[32m${route.method}\x1B[0m ${" ".repeat(length - route.method.length)} ${route.path}`
      );
    });
  }
  mount(path, applicationHandler, optionHandler) {
    const mergedPath = mergePath(this._basePath, path);
    const pathPrefixLength = mergedPath === "/" ? 0 : mergedPath.length;
    const handler = async (c, next) => {
      let executionContext = void 0;
      try {
        executionContext = c.executionCtx;
      } catch {
      }
      const options = optionHandler ? optionHandler(c) : [c.env, executionContext];
      const optionsArray = Array.isArray(options) ? options : [options];
      const queryStrings = getQueryStrings(c.req.url);
      const res = await applicationHandler(
        new Request(
          new URL((c.req.path.slice(pathPrefixLength) || "/") + queryStrings, c.req.url),
          c.req.raw
        ),
        ...optionsArray
      );
      if (res)
        return res;
      await next();
    };
    this.addRoute(METHOD_NAME_ALL, mergePath(path, "*"), handler);
    return this;
  }
  get routerName() {
    this.matchRoute("GET", "/");
    return this.router.name;
  }
  addRoute(method, path, handler) {
    method = method.toUpperCase();
    path = mergePath(this._basePath, path);
    this.router.add(method, path, handler);
    const r = { path, method, handler };
    this.routes.push(r);
  }
  matchRoute(method, path) {
    return this.router.match(method, path);
  }
  handleError(err, c) {
    if (err instanceof Error) {
      return this.errorHandler(err, c);
    }
    throw err;
  }
  dispatch(request, executionCtx, env, method) {
    if (method === "HEAD") {
      return (async () => new Response(null, await this.dispatch(request, executionCtx, env, "GET")))();
    }
    const path = this.getPath(request, { env });
    const [handlers, paramStash] = this.matchRoute(method, path);
    const c = new Context(new HonoRequest(request, path, paramStash || []), {
      env,
      executionCtx,
      notFoundHandler: this.notFoundHandler
    });
    if (handlers.length === 1) {
      let res;
      c.req.setParams(handlers[0][1]);
      try {
        res = handlers[0][0](c, async () => {
        });
        if (!res) {
          return this.notFoundHandler(c);
        }
      } catch (err) {
        return this.handleError(err, c);
      }
      if (res instanceof Response)
        return res;
      if ("response" in res) {
        res = res.response;
      }
      if (res instanceof Response)
        return res;
      return (async () => {
        let awaited;
        try {
          awaited = await res;
          if (awaited !== void 0 && "response" in awaited) {
            awaited = awaited["response"];
          }
          if (!awaited) {
            return this.notFoundHandler(c);
          }
        } catch (err) {
          return this.handleError(err, c);
        }
        return awaited;
      })();
    }
    const composed = compose(handlers, this.errorHandler, this.notFoundHandler);
    return (async () => {
      try {
        const tmp = composed(c);
        const context = tmp.constructor.name === "Promise" ? await tmp : tmp;
        if (!context.finalized) {
          throw new Error(
            "Context is not finalized. You may forget returning Response object or `await next()`"
          );
        }
        return context.res;
      } catch (err) {
        return this.handleError(err, c);
      }
    })();
  }
};

// node_modules/.pnpm/hono@3.8.1/node_modules/hono/dist/router/reg-exp-router/node.js
var LABEL_REG_EXP_STR = "[^/]+";
var ONLY_WILDCARD_REG_EXP_STR = ".*";
var TAIL_WILDCARD_REG_EXP_STR = "(?:|/.*)";
var PATH_ERROR = Symbol();
function compareKey(a, b) {
  if (a.length === 1) {
    return b.length === 1 ? a < b ? -1 : 1 : -1;
  }
  if (b.length === 1) {
    return 1;
  }
  if (a === ONLY_WILDCARD_REG_EXP_STR || a === TAIL_WILDCARD_REG_EXP_STR) {
    return 1;
  } else if (b === ONLY_WILDCARD_REG_EXP_STR || b === TAIL_WILDCARD_REG_EXP_STR) {
    return -1;
  }
  if (a === LABEL_REG_EXP_STR) {
    return 1;
  } else if (b === LABEL_REG_EXP_STR) {
    return -1;
  }
  return a.length === b.length ? a < b ? -1 : 1 : b.length - a.length;
}
var Node = class {
  constructor() {
    this.children = {};
  }
  insert(tokens, index, paramMap, context, pathErrorCheckOnly) {
    if (tokens.length === 0) {
      if (this.index !== void 0) {
        throw PATH_ERROR;
      }
      if (pathErrorCheckOnly) {
        return;
      }
      this.index = index;
      return;
    }
    const [token, ...restTokens] = tokens;
    const pattern = token === "*" ? restTokens.length === 0 ? ["", "", ONLY_WILDCARD_REG_EXP_STR] : ["", "", LABEL_REG_EXP_STR] : token === "/*" ? ["", "", TAIL_WILDCARD_REG_EXP_STR] : token.match(/^\:([^\{\}]+)(?:\{(.+)\})?$/);
    let node;
    if (pattern) {
      const name = pattern[1];
      let regexpStr = pattern[2] || LABEL_REG_EXP_STR;
      if (name && pattern[2]) {
        regexpStr = regexpStr.replace(/^\((?!\?:)(?=[^)]+\)$)/, "(?:");
        if (/\((?!\?:)/.test(regexpStr)) {
          throw PATH_ERROR;
        }
      }
      node = this.children[regexpStr];
      if (!node) {
        if (Object.keys(this.children).some(
          (k) => k !== ONLY_WILDCARD_REG_EXP_STR && k !== TAIL_WILDCARD_REG_EXP_STR
        )) {
          throw PATH_ERROR;
        }
        if (pathErrorCheckOnly) {
          return;
        }
        node = this.children[regexpStr] = new Node();
        if (name !== "") {
          node.varIndex = context.varIndex++;
        }
      }
      if (!pathErrorCheckOnly && name !== "") {
        paramMap.push([name, node.varIndex]);
      }
    } else {
      node = this.children[token];
      if (!node) {
        if (Object.keys(this.children).some(
          (k) => k.length > 1 && k !== ONLY_WILDCARD_REG_EXP_STR && k !== TAIL_WILDCARD_REG_EXP_STR
        )) {
          throw PATH_ERROR;
        }
        if (pathErrorCheckOnly) {
          return;
        }
        node = this.children[token] = new Node();
      }
    }
    node.insert(restTokens, index, paramMap, context, pathErrorCheckOnly);
  }
  buildRegExpStr() {
    const childKeys = Object.keys(this.children).sort(compareKey);
    const strList = childKeys.map((k) => {
      const c = this.children[k];
      return (typeof c.varIndex === "number" ? `(${k})@${c.varIndex}` : k) + c.buildRegExpStr();
    });
    if (typeof this.index === "number") {
      strList.unshift(`#${this.index}`);
    }
    if (strList.length === 0) {
      return "";
    }
    if (strList.length === 1) {
      return strList[0];
    }
    return "(?:" + strList.join("|") + ")";
  }
};

// node_modules/.pnpm/hono@3.8.1/node_modules/hono/dist/router/reg-exp-router/trie.js
var Trie = class {
  constructor() {
    this.context = { varIndex: 0 };
    this.root = new Node();
  }
  insert(path, index, pathErrorCheckOnly) {
    const paramAssoc = [];
    const groups = [];
    for (let i = 0; ; ) {
      let replaced = false;
      path = path.replace(/\{[^}]+\}/g, (m) => {
        const mark = `@\\${i}`;
        groups[i] = [mark, m];
        i++;
        replaced = true;
        return mark;
      });
      if (!replaced) {
        break;
      }
    }
    const tokens = path.match(/(?::[^\/]+)|(?:\/\*$)|./g) || [];
    for (let i = groups.length - 1; i >= 0; i--) {
      const [mark] = groups[i];
      for (let j = tokens.length - 1; j >= 0; j--) {
        if (tokens[j].indexOf(mark) !== -1) {
          tokens[j] = tokens[j].replace(mark, groups[i][1]);
          break;
        }
      }
    }
    this.root.insert(tokens, index, paramAssoc, this.context, pathErrorCheckOnly);
    return paramAssoc;
  }
  buildRegExp() {
    let regexp = this.root.buildRegExpStr();
    if (regexp === "") {
      return [/^$/, [], []];
    }
    let captureIndex = 0;
    const indexReplacementMap = [];
    const paramReplacementMap = [];
    regexp = regexp.replace(/#(\d+)|@(\d+)|\.\*\$/g, (_, handlerIndex, paramIndex) => {
      if (typeof handlerIndex !== "undefined") {
        indexReplacementMap[++captureIndex] = Number(handlerIndex);
        return "$()";
      }
      if (typeof paramIndex !== "undefined") {
        paramReplacementMap[Number(paramIndex)] = ++captureIndex;
        return "";
      }
      return "";
    });
    return [new RegExp(`^${regexp}`), indexReplacementMap, paramReplacementMap];
  }
};

// node_modules/.pnpm/hono@3.8.1/node_modules/hono/dist/router/reg-exp-router/router.js
var methodNames = [METHOD_NAME_ALL, ...METHODS].map((method) => method.toUpperCase());
var emptyParam = [];
var nullMatcher = [/^$/, [], {}];
var wildcardRegExpCache = {};
function buildWildcardRegExp(path) {
  return wildcardRegExpCache[path] ?? (wildcardRegExpCache[path] = new RegExp(
    path === "*" ? "" : `^${path.replace(/\/\*/, "(?:|/.*)")}$`
  ));
}
function clearWildcardRegExpCache() {
  wildcardRegExpCache = {};
}
function buildMatcherFromPreprocessedRoutes(routes) {
  const trie = new Trie();
  const handlerData = [];
  if (routes.length === 0) {
    return nullMatcher;
  }
  const routesWithStaticPathFlag = routes.map(
    (route) => [!/\*|\/:/.test(route[0]), ...route]
  ).sort(
    ([isStaticA, pathA], [isStaticB, pathB]) => isStaticA ? 1 : isStaticB ? -1 : pathA.length - pathB.length
  );
  const staticMap = {};
  for (let i = 0, j = -1, len = routesWithStaticPathFlag.length; i < len; i++) {
    const [pathErrorCheckOnly, path, handlers] = routesWithStaticPathFlag[i];
    if (pathErrorCheckOnly) {
      staticMap[path] = [handlers.map(([h]) => [h, {}]), emptyParam];
    } else {
      j++;
    }
    let paramAssoc;
    try {
      paramAssoc = trie.insert(path, j, pathErrorCheckOnly);
    } catch (e) {
      throw e === PATH_ERROR ? new UnsupportedPathError(path) : e;
    }
    if (pathErrorCheckOnly) {
      continue;
    }
    handlerData[j] = handlers.map(([h, paramCount]) => {
      const paramIndexMap = {};
      paramCount -= 1;
      for (; paramCount >= 0; paramCount--) {
        const [key, value] = paramAssoc[paramCount];
        paramIndexMap[key] = value;
      }
      return [h, paramIndexMap];
    });
  }
  const [regexp, indexReplacementMap, paramReplacementMap] = trie.buildRegExp();
  for (let i = 0, len = handlerData.length; i < len; i++) {
    for (let j = 0, len2 = handlerData[i].length; j < len2; j++) {
      const map = handlerData[i][j]?.[1];
      if (!map) {
        continue;
      }
      const keys = Object.keys(map);
      for (let k = 0, len3 = keys.length; k < len3; k++) {
        map[keys[k]] = paramReplacementMap[map[keys[k]]];
      }
    }
  }
  const handlerMap = [];
  for (const i in indexReplacementMap) {
    handlerMap[i] = handlerData[indexReplacementMap[i]];
  }
  return [regexp, handlerMap, staticMap];
}
function findMiddleware(middleware, path) {
  if (!middleware) {
    return void 0;
  }
  for (const k of Object.keys(middleware).sort((a, b) => b.length - a.length)) {
    if (buildWildcardRegExp(k).test(path)) {
      return [...middleware[k]];
    }
  }
  return void 0;
}
var RegExpRouter = class {
  constructor() {
    this.name = "RegExpRouter";
    this.middleware = { [METHOD_NAME_ALL]: {} };
    this.routes = { [METHOD_NAME_ALL]: {} };
  }
  add(method, path, handler) {
    var _a;
    const { middleware, routes } = this;
    if (!middleware || !routes) {
      throw new Error("Can not add a route since the matcher is already built.");
    }
    if (methodNames.indexOf(method) === -1)
      methodNames.push(method);
    if (!middleware[method]) {
      ;
      [middleware, routes].forEach((handlerMap) => {
        handlerMap[method] = {};
        Object.keys(handlerMap[METHOD_NAME_ALL]).forEach((p) => {
          handlerMap[method][p] = [...handlerMap[METHOD_NAME_ALL][p]];
        });
      });
    }
    if (path === "/*") {
      path = "*";
    }
    const paramCount = (path.match(/\/:/g) || []).length;
    if (/\*$/.test(path)) {
      const re = buildWildcardRegExp(path);
      if (method === METHOD_NAME_ALL) {
        Object.keys(middleware).forEach((m) => {
          var _a2;
          (_a2 = middleware[m])[path] || (_a2[path] = findMiddleware(middleware[m], path) || findMiddleware(middleware[METHOD_NAME_ALL], path) || []);
        });
      } else {
        (_a = middleware[method])[path] || (_a[path] = findMiddleware(middleware[method], path) || findMiddleware(middleware[METHOD_NAME_ALL], path) || []);
      }
      Object.keys(middleware).forEach((m) => {
        if (method === METHOD_NAME_ALL || method === m) {
          Object.keys(middleware[m]).forEach((p) => {
            re.test(p) && middleware[m][p].push([handler, paramCount]);
          });
        }
      });
      Object.keys(routes).forEach((m) => {
        if (method === METHOD_NAME_ALL || method === m) {
          Object.keys(routes[m]).forEach(
            (p) => re.test(p) && routes[m][p].push([handler, paramCount])
          );
        }
      });
      return;
    }
    const paths = checkOptionalParameter(path) || [path];
    for (let i = 0, len = paths.length; i < len; i++) {
      const path2 = paths[i];
      Object.keys(routes).forEach((m) => {
        var _a2;
        if (method === METHOD_NAME_ALL || method === m) {
          (_a2 = routes[m])[path2] || (_a2[path2] = [
            ...findMiddleware(middleware[m], path2) || findMiddleware(middleware[METHOD_NAME_ALL], path2) || []
          ]);
          routes[m][path2].push([
            handler,
            paths.length === 2 && i === 0 ? paramCount - 1 : paramCount
          ]);
        }
      });
    }
  }
  match(method, path) {
    clearWildcardRegExpCache();
    const matchers = this.buildAllMatchers();
    this.match = (method2, path2) => {
      const matcher = matchers[method2];
      const staticMatch = matcher[2][path2];
      if (staticMatch) {
        return staticMatch;
      }
      const match = path2.match(matcher[0]);
      if (!match) {
        return [[], emptyParam];
      }
      const index = match.indexOf("", 1);
      return [matcher[1][index], match];
    };
    return this.match(method, path);
  }
  buildAllMatchers() {
    const matchers = {};
    methodNames.forEach((method) => {
      matchers[method] = this.buildMatcher(method) || matchers[METHOD_NAME_ALL];
    });
    this.middleware = this.routes = void 0;
    return matchers;
  }
  buildMatcher(method) {
    const routes = [];
    let hasOwnRoute = method === METHOD_NAME_ALL;
    [this.middleware, this.routes].forEach((r) => {
      const ownRoute = r[method] ? Object.keys(r[method]).map((path) => [path, r[method][path]]) : [];
      if (ownRoute.length !== 0) {
        hasOwnRoute || (hasOwnRoute = true);
        routes.push(...ownRoute);
      } else if (method !== METHOD_NAME_ALL) {
        routes.push(
          ...Object.keys(r[METHOD_NAME_ALL]).map((path) => [path, r[METHOD_NAME_ALL][path]])
        );
      }
    });
    if (!hasOwnRoute) {
      return null;
    } else {
      return buildMatcherFromPreprocessedRoutes(routes);
    }
  }
};

// node_modules/.pnpm/hono@3.8.1/node_modules/hono/dist/router/smart-router/router.js
var SmartRouter = class {
  constructor(init2) {
    this.name = "SmartRouter";
    this.routers = [];
    this.routes = [];
    Object.assign(this, init2);
  }
  add(method, path, handler) {
    if (!this.routes) {
      throw new Error("Can not add a route since the matcher is already built.");
    }
    this.routes.push([method, path, handler]);
  }
  match(method, path) {
    if (!this.routes) {
      throw new Error("Fatal error");
    }
    const { routers, routes } = this;
    const len = routers.length;
    let i = 0;
    let res;
    for (; i < len; i++) {
      const router = routers[i];
      try {
        routes.forEach((args) => {
          router.add(...args);
        });
        res = router.match(method, path);
      } catch (e) {
        if (e instanceof UnsupportedPathError) {
          continue;
        }
        throw e;
      }
      this.match = router.match.bind(router);
      this.routers = [router];
      this.routes = void 0;
      break;
    }
    if (i === len) {
      throw new Error("Fatal error");
    }
    this.name = `SmartRouter + ${this.activeRouter.name}`;
    return res;
  }
  get activeRouter() {
    if (this.routes || this.routers.length !== 1) {
      throw new Error("No active router has been determined yet.");
    }
    return this.routers[0];
  }
};

// node_modules/.pnpm/hono@3.8.1/node_modules/hono/dist/router/trie-router/node.js
var Node2 = class {
  constructor(method, handler, children) {
    this.order = 0;
    this.params = {};
    this.children = children || {};
    this.methods = [];
    this.name = "";
    if (method && handler) {
      const m = {};
      m[method] = { handler, params: {}, possibleKeys: [], score: 0, name: this.name };
      this.methods = [m];
    }
    this.patterns = [];
  }
  insert(method, path, handler) {
    this.name = `${method} ${path}`;
    this.order = ++this.order;
    let curNode = this;
    const parts = splitRoutingPath(path);
    const possibleKeys = [];
    const parentPatterns = [];
    for (let i = 0, len = parts.length; i < len; i++) {
      const p = parts[i];
      if (Object.keys(curNode.children).includes(p)) {
        parentPatterns.push(...curNode.patterns);
        curNode = curNode.children[p];
        const pattern2 = getPattern(p);
        if (pattern2)
          possibleKeys.push(pattern2[1]);
        continue;
      }
      curNode.children[p] = new Node2();
      const pattern = getPattern(p);
      if (pattern) {
        curNode.patterns.push(pattern);
        parentPatterns.push(...curNode.patterns);
        possibleKeys.push(pattern[1]);
      }
      parentPatterns.push(...curNode.patterns);
      curNode = curNode.children[p];
    }
    if (!curNode.methods.length) {
      curNode.methods = [];
    }
    const m = {};
    const handlerSet = {
      handler,
      params: {},
      possibleKeys,
      name: this.name,
      score: this.order
    };
    m[method] = handlerSet;
    curNode.methods.push(m);
    return curNode;
  }
  gHSets(node, method, params) {
    const handlerSets = [];
    for (let i = 0, len = node.methods.length; i < len; i++) {
      const m = node.methods[i];
      const handlerSet = m[method] || m[METHOD_NAME_ALL];
      if (handlerSet !== void 0) {
        handlerSet.possibleKeys.map((key) => {
          handlerSet.params[key] = params[key];
        });
        handlerSets.push(handlerSet);
      }
    }
    return handlerSets;
  }
  search(method, path) {
    const handlerSets = [];
    const params = {};
    this.params = {};
    const curNode = this;
    let curNodes = [curNode];
    const parts = splitPath(path);
    for (let i = 0, len = parts.length; i < len; i++) {
      const part = parts[i];
      const isLast = i === len - 1;
      const tempNodes = [];
      for (let j = 0, len2 = curNodes.length; j < len2; j++) {
        const node = curNodes[j];
        const nextNode = node.children[part];
        if (nextNode) {
          if (isLast === true) {
            if (nextNode.children["*"]) {
              handlerSets.push(
                ...this.gHSets(nextNode.children["*"], method, { ...params, ...node.params })
              );
            }
            handlerSets.push(...this.gHSets(nextNode, method, { ...params, ...node.params }));
          } else {
            tempNodes.push(nextNode);
          }
        }
        for (let k = 0, len3 = node.patterns.length; k < len3; k++) {
          const pattern = node.patterns[k];
          if (pattern === "*") {
            const astNode = node.children["*"];
            if (astNode) {
              handlerSets.push(...this.gHSets(astNode, method, { ...params, ...node.params }));
              tempNodes.push(astNode);
            }
            continue;
          }
          if (part === "")
            continue;
          const [key, name, matcher] = pattern;
          const child = node.children[key];
          const restPathString = parts.slice(i).join("/");
          if (matcher instanceof RegExp && matcher.test(restPathString)) {
            params[name] = restPathString;
            handlerSets.push(...this.gHSets(child, method, { ...params, ...node.params }));
            continue;
          }
          if (matcher === true || matcher instanceof RegExp && matcher.test(part)) {
            if (typeof key === "string") {
              params[name] = part;
              if (isLast === true) {
                handlerSets.push(...this.gHSets(child, method, { ...params, ...node.params }));
                if (child.children["*"]) {
                  handlerSets.push(
                    ...this.gHSets(child.children["*"], method, { ...params, ...node.params })
                  );
                }
              } else {
                child.params = { ...params };
                tempNodes.push(child);
              }
            }
          }
        }
      }
      curNodes = tempNodes;
    }
    const results = handlerSets.sort((a, b) => {
      return a.score - b.score;
    });
    return [results.map(({ handler, params: params2 }) => [handler, params2])];
  }
};

// node_modules/.pnpm/hono@3.8.1/node_modules/hono/dist/router/trie-router/router.js
var TrieRouter = class {
  constructor() {
    this.name = "TrieRouter";
    this.node = new Node2();
  }
  add(method, path, handler) {
    const results = checkOptionalParameter(path);
    if (results) {
      for (const p of results) {
        this.node.insert(method, p, handler);
      }
      return;
    }
    this.node.insert(method, path, handler);
  }
  match(method, path) {
    return this.node.search(method, path);
  }
};

// node_modules/.pnpm/hono@3.8.1/node_modules/hono/dist/hono.js
var Hono2 = class extends Hono {
  constructor(options = {}) {
    super(options);
    this.router = options.router ?? new SmartRouter({
      routers: [new RegExpRouter(), new TrieRouter()]
    });
  }
};

// node_modules/.pnpm/@hono+node-server@1.2.0/node_modules/@hono/node-server/dist/server.mjs
var import_node_http = require("node:http");

// node_modules/.pnpm/@hono+node-server@1.2.0/node_modules/@hono/node-server/dist/listener.mjs
var import_node_stream = require("node:stream");
var import_promises = require("node:stream/promises");

// node_modules/.pnpm/@hono+node-server@1.2.0/node_modules/@hono/node-server/dist/globals.mjs
var import_node_crypto = __toESM(require("node:crypto"), 1);
var webFetch = global.fetch;
if (typeof global.crypto === "undefined") {
  global.crypto = import_node_crypto.default;
}
global.fetch = (info, init2) => {
  init2 = {
    // Disable compression handling so people can return the result of a fetch
    // directly in the loader without messing with the Content-Encoding header.
    compress: false,
    ...init2
  };
  return webFetch(info, init2);
};

// node_modules/.pnpm/@hono+node-server@1.2.0/node_modules/@hono/node-server/dist/listener.mjs
var getRequestListener = (fetchCallback) => {
  return async (incoming, outgoing) => {
    const method = incoming.method || "GET";
    const url = `http://${incoming.headers.host}${incoming.url}`;
    const headerRecord = [];
    const len = incoming.rawHeaders.length;
    for (let i = 0; i < len; i += 2) {
      headerRecord.push([incoming.rawHeaders[i], incoming.rawHeaders[i + 1]]);
    }
    const init2 = {
      method,
      headers: headerRecord
    };
    if (!(method === "GET" || method === "HEAD")) {
      init2.body = import_node_stream.Readable.toWeb(incoming);
      init2.duplex = "half";
    }
    let res;
    try {
      res = await fetchCallback(new Request(url.toString(), init2));
    } catch (e) {
      res = new Response(null, { status: 500 });
      if (e instanceof Error) {
        if (e.name === "TimeoutError" || e.constructor.name === "TimeoutError") {
          res = new Response(null, { status: 504 });
        }
      }
    }
    const contentType = res.headers.get("content-type") || "";
    const buffering = res.headers.get("x-accel-buffering") || "";
    const contentEncoding = res.headers.get("content-encoding");
    const contentLength = res.headers.get("content-length");
    const transferEncoding = res.headers.get("transfer-encoding");
    for (const [k, v] of res.headers) {
      if (k === "set-cookie") {
        outgoing.setHeader(k, res.headers.getSetCookie(k));
      } else {
        outgoing.setHeader(k, v);
      }
    }
    outgoing.statusCode = res.status;
    if (res.body) {
      try {
        if (contentEncoding || transferEncoding || contentLength || /^no$/i.test(buffering) || !/^(application\/json\b|text\/(?!event-stream\b))/i.test(contentType)) {
          await (0, import_promises.pipeline)(import_node_stream.Readable.fromWeb(res.body), outgoing);
        } else {
          const text = await res.text();
          outgoing.setHeader("Content-Length", Buffer.byteLength(text));
          outgoing.end(text);
        }
      } catch (e) {
        const err = e instanceof Error ? e : new Error("unknown error", { cause: e });
        if (err.code === "ERR_STREAM_PREMATURE_CLOSE") {
          console.info("The user aborted a request.");
        } else {
          console.error(e);
          outgoing.destroy(err);
        }
      }
    } else {
      outgoing.end();
    }
  };
};

// node_modules/.pnpm/@hono+node-server@1.2.0/node_modules/@hono/node-server/dist/server.mjs
var createAdaptorServer = (options) => {
  const fetchCallback = options.fetch;
  const requestListener = getRequestListener(fetchCallback);
  const createServer2 = options.createServer || import_node_http.createServer;
  const server = createServer2(options.serverOptions || {}, requestListener);
  return server;
};
var serve = (options, listeningListener) => {
  const server = createAdaptorServer(options);
  server.listen(options?.port ?? 3e3, options.hostname ?? "0.0.0.0", () => {
    const serverInfo = server.address();
    listeningListener && listeningListener(serverInfo);
  });
  return server;
};

// node_modules/.pnpm/hono@3.8.1/node_modules/hono/dist/middleware/cors/index.js
var cors = (options) => {
  const defaults = {
    origin: "*",
    allowMethods: ["GET", "HEAD", "PUT", "POST", "DELETE", "PATCH"],
    allowHeaders: [],
    exposeHeaders: []
  };
  const opts = {
    ...defaults,
    ...options
  };
  const findAllowOrigin = ((optsOrigin) => {
    if (typeof optsOrigin === "string") {
      return () => optsOrigin;
    } else if (typeof optsOrigin === "function") {
      return optsOrigin;
    } else {
      return (origin) => optsOrigin.includes(origin) ? origin : optsOrigin[0];
    }
  })(opts.origin);
  return async (c, next) => {
    function set(key, value) {
      c.res.headers.set(key, value);
    }
    const allowOrigin = findAllowOrigin(c.req.header("origin") || "");
    if (allowOrigin) {
      set("Access-Control-Allow-Origin", allowOrigin);
    }
    if (opts.origin !== "*") {
      set("Vary", "Origin");
    }
    if (opts.credentials) {
      set("Access-Control-Allow-Credentials", "true");
    }
    if (opts.exposeHeaders?.length) {
      set("Access-Control-Expose-Headers", opts.exposeHeaders.join(","));
    }
    if (c.req.method !== "OPTIONS") {
      await next();
    } else {
      if (opts.maxAge != null) {
        set("Access-Control-Max-Age", opts.maxAge.toString());
      }
      if (opts.allowMethods?.length) {
        set("Access-Control-Allow-Methods", opts.allowMethods.join(","));
      }
      let headers = opts.allowHeaders;
      if (!headers?.length) {
        const requestHeaders = c.req.header("Access-Control-Request-Headers");
        if (requestHeaders) {
          headers = requestHeaders.split(/\s*,\s*/);
        }
      }
      if (headers?.length) {
        set("Access-Control-Allow-Headers", headers.join(","));
        c.res.headers.append("Vary", "Access-Control-Request-Headers");
      }
      c.res.headers.delete("Content-Length");
      c.res.headers.delete("Content-Type");
      return new Response(null, {
        headers: c.res.headers,
        status: 204,
        statusText: c.res.statusText
      });
    }
  };
};

// src/server.ts
var import_valibot_validator = __toESM(require_cjs());

// node_modules/.pnpm/valibot@0.19.0/node_modules/valibot/dist/index.js
var BrandSymbol = Symbol("brand");
function getIssues(issues) {
  return { issues };
}
function getOutput(output) {
  return { output };
}
function getIssue(info, issue) {
  return {
    reason: info?.reason,
    validation: issue.validation,
    origin: info?.origin || "value",
    message: issue.message,
    input: issue.input,
    path: issue.path,
    abortEarly: info?.abortEarly,
    abortPipeEarly: info?.abortPipeEarly,
    skipPipe: info?.skipPipe
  };
}
function getPipeInfo(info, reason) {
  return {
    reason,
    origin: info?.origin,
    abortEarly: info?.abortEarly,
    abortPipeEarly: info?.abortPipeEarly,
    skipPipe: info?.skipPipe
  };
}
function executePipe(input, pipe, parseInfo, reason) {
  if (!pipe || !pipe.length || parseInfo?.skipPipe) {
    return getOutput(input);
  }
  let pipeInfo;
  let issues;
  let output = input;
  for (const action of pipe) {
    const result = action(output);
    if (result.issues) {
      pipeInfo = pipeInfo || getPipeInfo(parseInfo, reason);
      for (const issueInfo of result.issues) {
        const issue = getIssue(pipeInfo, issueInfo);
        issues ? issues.push(issue) : issues = [issue];
      }
      if (pipeInfo.abortEarly || pipeInfo.abortPipeEarly) {
        break;
      }
    } else {
      output = result.output;
    }
  }
  return issues ? getIssues(issues) : getOutput(output);
}
function getDefaultArgs(arg1, arg2) {
  return Array.isArray(arg1) ? [void 0, arg1] : [arg1, arg2];
}
function getErrorMessage(error) {
  return typeof error === "function" ? error() : error;
}
function getSchemaIssues(info, reason, validation, error, input, issues) {
  return {
    issues: [
      {
        reason,
        validation,
        origin: info?.origin || "value",
        message: getErrorMessage(error),
        input,
        issues,
        abortEarly: info?.abortEarly,
        abortPipeEarly: info?.abortPipeEarly,
        skipPipe: info?.skipPipe
      }
    ]
  };
}
function any(pipe = []) {
  return {
    /**
     * The schema type.
     */
    schema: "any",
    /**
     * Whether it's async.
     */
    async: false,
    /**
     * Parses unknown input based on its schema.
     *
     * @param input The input to be parsed.
     * @param info The parse info.
     *
     * @returns The parsed output.
     */
    _parse(input, info) {
      return executePipe(input, pipe, info, "any");
    }
  };
}
function array(item, arg2, arg3) {
  const [error, pipe] = getDefaultArgs(arg2, arg3);
  return {
    /**
     * The schema type.
     */
    schema: "array",
    /**
     * The array item schema.
     */
    array: { item },
    /**
     * Whether it's async.
     */
    async: false,
    /**
     * Parses unknown input based on its schema.
     *
     * @param input The input to be parsed.
     * @param info The parse info.
     *
     * @returns The parsed output.
     */
    _parse(input, info) {
      if (!Array.isArray(input)) {
        return getSchemaIssues(
          info,
          "type",
          "array",
          error || "Invalid type",
          input
        );
      }
      let issues;
      const output = [];
      for (let key = 0; key < input.length; key++) {
        const value2 = input[key];
        const result = item._parse(value2, info);
        if (result.issues) {
          const pathItem = {
            schema: "array",
            input,
            key,
            value: value2
          };
          for (const issue of result.issues) {
            if (issue.path) {
              issue.path.unshift(pathItem);
            } else {
              issue.path = [pathItem];
            }
            issues?.push(issue);
          }
          if (!issues) {
            issues = result.issues;
          }
          if (info?.abortEarly) {
            break;
          }
        } else {
          output.push(result.output);
        }
      }
      return issues ? getIssues(issues) : executePipe(output, pipe, info, "array");
    }
  };
}
function boolean(arg1, arg2) {
  const [error, pipe] = getDefaultArgs(arg1, arg2);
  return {
    /**
     * The schema type.
     */
    schema: "boolean",
    /**
     * Whether it's async.
     */
    async: false,
    /**
     * Parses unknown input based on its schema.
     *
     * @param input The input to be parsed.
     * @param info The parse info.
     *
     * @returns The parsed output.
     */
    _parse(input, info) {
      if (typeof input !== "boolean") {
        return getSchemaIssues(
          info,
          "type",
          "boolean",
          error || "Invalid type",
          input
        );
      }
      return executePipe(input, pipe, info, "boolean");
    }
  };
}
function enumType(enumValue, error) {
  return {
    /**
     * The schema type.
     */
    schema: "enum",
    /**
     * The enum value.
     */
    enum: enumValue,
    /**
     * Whether it's async.
     */
    async: false,
    /**
     * Parses unknown input based on its schema.
     *
     * @param input The input to be parsed.
     * @param info The parse info.
     *
     * @returns The parsed output.
     */
    _parse(input, info) {
      if (!enumValue.includes(input)) {
        return getSchemaIssues(
          info,
          "type",
          "enum",
          error || "Invalid type",
          input
        );
      }
      return getOutput(input);
    }
  };
}
function literal(literal2, error) {
  return {
    /**
     * The schema type.
     */
    schema: "literal",
    /**
     * The literal value.
     */
    literal: literal2,
    /**
     * Whether it's async.
     */
    async: false,
    /**
     * Parses unknown input based on its schema.
     *
     * @param input The input to be parsed.
     * @param info The parse info.
     *
     * @returns The parsed output.
     */
    _parse(input, info) {
      if (input !== literal2) {
        return getSchemaIssues(
          info,
          "type",
          "literal",
          error || "Invalid type",
          input
        );
      }
      return getOutput(input);
    }
  };
}
function number(arg1, arg2) {
  const [error, pipe] = getDefaultArgs(arg1, arg2);
  return {
    /**
     * The schema type.
     */
    schema: "number",
    /**
     * Whether it's async.
     */
    async: false,
    /**
     * Parses unknown input based on its schema.
     *
     * @param input The input to be parsed.
     * @param info The parse info.
     *
     * @returns The parsed output.
     */
    _parse(input, info) {
      if (typeof input !== "number" || Number.isNaN(input)) {
        return getSchemaIssues(
          info,
          "type",
          "number",
          error || "Invalid type",
          input
        );
      }
      return executePipe(input, pipe, info, "number");
    }
  };
}
function object(object2, arg2, arg3) {
  const [error, pipe] = getDefaultArgs(arg2, arg3);
  let cachedEntries;
  return {
    /**
     * The schema type.
     */
    schema: "object",
    /**
     * The object schema.
     */
    object: object2,
    /**
     * Whether it's async.
     */
    async: false,
    /**
     * Parses unknown input based on its schema.
     *
     * @param input The input to be parsed.
     * @param info The parse info.
     *
     * @returns The parsed output.
     */
    _parse(input, info) {
      if (!input || typeof input !== "object") {
        return getSchemaIssues(
          info,
          "type",
          "object",
          error || "Invalid type",
          input
        );
      }
      cachedEntries = cachedEntries || Object.entries(object2);
      let issues;
      const output = {};
      for (const [key, schema2] of cachedEntries) {
        const value2 = input[key];
        const result = schema2._parse(value2, info);
        if (result.issues) {
          const pathItem = {
            schema: "object",
            input,
            key,
            value: value2
          };
          for (const issue of result.issues) {
            if (issue.path) {
              issue.path.unshift(pathItem);
            } else {
              issue.path = [pathItem];
            }
            issues?.push(issue);
          }
          if (!issues) {
            issues = result.issues;
          }
          if (info?.abortEarly) {
            break;
          }
        } else if (result.output !== void 0 || key in input) {
          output[key] = result.output;
        }
      }
      return issues ? getIssues(issues) : executePipe(
        output,
        pipe,
        info,
        "object"
      );
    }
  };
}
function optional(wrapped, default_) {
  return {
    /**
     * The schema type.
     */
    schema: "optional",
    /**
     * The wrapped schema.
     */
    wrapped,
    /**
     * The default value.
     */
    get default() {
      return typeof default_ === "function" ? default_() : default_;
    },
    /**
     * Whether it's async.
     */
    async: false,
    /**
     * Parses unknown input based on its schema.
     *
     * @param input The input to be parsed.
     * @param info The parse info.
     *
     * @returns The parsed output.
     */
    _parse(input, info) {
      const value2 = input === void 0 ? this.default : input;
      if (value2 === void 0) {
        return getOutput(value2);
      }
      return wrapped._parse(value2, info);
    }
  };
}
function string(arg1, arg2) {
  const [error, pipe] = getDefaultArgs(arg1, arg2);
  return {
    /**
     * The schema type.
     */
    schema: "string",
    /**
     * Whether it's async.
     */
    async: false,
    /**
     * Parses unknown input based on its schema.
     *
     * @param input The input to be parsed.
     * @param info The parse info.
     *
     * @returns The parsed output.
     */
    _parse(input, info) {
      if (typeof input !== "string") {
        return getSchemaIssues(
          info,
          "type",
          "string",
          error || "Invalid type",
          input
        );
      }
      return executePipe(input, pipe, info, "string");
    }
  };
}
function getRecordArgs(arg1, arg2, arg3, arg4) {
  if (typeof arg2 === "object" && !Array.isArray(arg2)) {
    const [error2, pipe2] = getDefaultArgs(arg3, arg4);
    return [arg1, arg2, error2, pipe2];
  }
  const [error, pipe] = getDefaultArgs(
    arg2,
    arg3
  );
  return [string(), arg1, error, pipe];
}
var BLOCKED_KEYS = ["__proto__", "prototype", "constructor"];
function record(arg1, arg2, arg3, arg4) {
  const [key, value2, error, pipe] = getRecordArgs(arg1, arg2, arg3, arg4);
  return {
    /**
     * The schema type.
     */
    schema: "record",
    /**
     * The record key and value schema.
     */
    record: { key, value: value2 },
    /**
     * Whether it's async.
     */
    async: false,
    /**
     * Parses unknown input based on its schema.
     *
     * @param input The input to be parsed.
     * @param info The parse info.
     *
     * @returns The parsed output.
     */
    _parse(input, info) {
      if (!input || typeof input !== "object") {
        return getSchemaIssues(
          info,
          "type",
          "record",
          error || "Invalid type",
          input
        );
      }
      let issues;
      const output = {};
      for (const [inputKey, inputValue] of Object.entries(input)) {
        if (!BLOCKED_KEYS.includes(inputKey)) {
          let pathItem;
          const keyResult = key._parse(inputKey, {
            origin: "key",
            abortEarly: info?.abortEarly,
            abortPipeEarly: info?.abortPipeEarly,
            skipPipe: info?.skipPipe
          });
          if (keyResult.issues) {
            pathItem = {
              schema: "record",
              input,
              key: inputKey,
              value: inputValue
            };
            for (const issue of keyResult.issues) {
              issue.path = [pathItem];
              issues?.push(issue);
            }
            if (!issues) {
              issues = keyResult.issues;
            }
            if (info?.abortEarly) {
              break;
            }
          }
          const valueResult = value2._parse(inputValue, info);
          if (valueResult.issues) {
            pathItem = pathItem || {
              schema: "record",
              input,
              key: inputKey,
              value: inputValue
            };
            for (const issue of valueResult.issues) {
              if (issue.path) {
                issue.path.unshift(pathItem);
              } else {
                issue.path = [pathItem];
              }
              issues?.push(issue);
            }
            if (!issues) {
              issues = valueResult.issues;
            }
            if (info?.abortEarly) {
              break;
            }
          }
          if (!keyResult.issues && !valueResult.issues) {
            output[keyResult.output] = valueResult.output;
          }
        }
      }
      return issues ? getIssues(issues) : executePipe(
        output,
        pipe,
        info,
        "record"
      );
    }
  };
}
function recursive(getter) {
  return {
    /**
     * The schema type.
     */
    schema: "recursive",
    /**
     * The schema getter.
     */
    getter,
    /**
     * Whether it's async.
     */
    async: false,
    /**
     * Parses unknown input based on its schema.
     *
     * @param input The input to be parsed.
     * @param info The parse info.
     *
     * @returns The parsed output.
     */
    _parse(input, info) {
      return getter()._parse(input, info);
    }
  };
}
function getTupleArgs(arg1, arg2, arg3) {
  if (typeof arg1 === "object" && !Array.isArray(arg1)) {
    const [error2, pipe2] = getDefaultArgs(arg2, arg3);
    return [arg1, error2, pipe2];
  }
  const [error, pipe] = getDefaultArgs(
    arg1,
    arg2
  );
  return [void 0, error, pipe];
}
function tuple(items, arg2, arg3, arg4) {
  const [rest, error, pipe] = getTupleArgs(arg2, arg3, arg4);
  return {
    /**
     * The schema type.
     */
    schema: "tuple",
    /**
     * The tuple items and rest schema.
     */
    tuple: { items, rest },
    /**
     * Whether it's async.
     */
    async: false,
    /**
     * Parses unknown input based on its schema.
     *
     * @param input The input to be parsed.
     * @param info The parse info.
     *
     * @returns The parsed output.
     */
    _parse(input, info) {
      if (!Array.isArray(input) || !rest && items.length !== input.length || rest && items.length > input.length) {
        return getSchemaIssues(
          info,
          "type",
          "tuple",
          error || "Invalid type",
          input
        );
      }
      let issues;
      const output = [];
      for (let key = 0; key < items.length; key++) {
        const value2 = input[key];
        const result = items[key]._parse(value2, info);
        if (result.issues) {
          const pathItem = {
            schema: "tuple",
            input,
            key,
            value: value2
          };
          for (const issue of result.issues) {
            if (issue.path) {
              issue.path.unshift(pathItem);
            } else {
              issue.path = [pathItem];
            }
            issues?.push(issue);
          }
          if (!issues) {
            issues = result.issues;
          }
          if (info?.abortEarly) {
            break;
          }
        } else {
          output[key] = result.output;
        }
      }
      if (rest) {
        for (let key = items.length; key < input.length; key++) {
          const value2 = input[key];
          const result = rest._parse(value2, info);
          if (result.issues) {
            const pathItem = {
              schema: "tuple",
              input,
              key,
              value: value2
            };
            for (const issue of result.issues) {
              if (issue.path) {
                issue.path.unshift(pathItem);
              } else {
                issue.path = [pathItem];
              }
              issues?.push(issue);
            }
            if (!issues) {
              issues = result.issues;
            }
            if (info?.abortEarly) {
              break;
            }
          } else {
            output[key] = result.output;
          }
        }
      }
      return issues ? getIssues(issues) : executePipe(
        output,
        pipe,
        info,
        "tuple"
      );
    }
  };
}
function union(union2, error) {
  return {
    /**
     * The schema type.
     */
    schema: "union",
    /**
     * The union schema.
     */
    union: union2,
    /**
     * Whether it's async.
     */
    async: false,
    /**
     * Parses unknown input based on its schema.
     *
     * @param input The input to be parsed.
     * @param info The parse info.
     *
     * @returns The parsed output.
     */
    _parse(input, info) {
      let issues;
      let output;
      for (const schema2 of union2) {
        const result = schema2._parse(input, info);
        if (result.issues) {
          if (issues) {
            for (const issue of result.issues) {
              issues.push(issue);
            }
          } else {
            issues = result.issues;
          }
        } else {
          output = [result.output];
          break;
        }
      }
      return output ? getOutput(output[0]) : getSchemaIssues(
        info,
        "type",
        "union",
        error || "Invalid type",
        input,
        issues
      );
    }
  };
}

// src/schema.ts
var sch = optional(string(), "public");
var filterOp = tuple([string(), string(), any()]);
var filterSchema = object({
  and: optional(array(recursive(() => filterSchema))),
  or: optional(array(recursive(() => filterSchema))),
  op: optional(filterOp)
});
var orderBySchema = object({
  column: string(),
  type: enumType(["ASC", "DESC"])
});
var init = object({
  type: literal("init")
});
var proxy = object({
  type: literal("proxy"),
  data: object({
    sql: string(),
    method: enumType(["all"]),
    params: array(any())
  })
});
var rawSqlQuery = object({
  type: literal("raw-sql"),
  data: string()
});
var tablesSchema = object({
  type: literal("sql-schema"),
  schema: sch,
  data: optional(
    object({
      count: boolean()
    })
  )
});
var insertSchema = object({
  type: enumType(["sql-insert"]),
  schema: sch,
  data: object({
    table: string(),
    data: record(any())
  })
});
var selectSchema = object({
  type: enumType(["sql-select"]),
  schema: sch,
  data: object({
    table: string(),
    columns: optional(array(string())),
    where: optional(filterSchema),
    orderBy: optional(orderBySchema),
    limit: number(),
    offset: number()
  })
});
var updateSchema = object({
  type: enumType(["sql-update"]),
  schema: sch,
  data: object({
    table: string(),
    where: filterSchema,
    data: record(any())
  })
});
var deleteSchema = object({
  type: enumType(["sql-delete"]),
  schema: sch,
  data: object({
    table: string(),
    where: filterSchema
  })
});
var truncateSchema = object({
  type: enumType(["sql-truncate"]),
  schema: sch,
  data: object({
    table: string(),
    isCascade: optional(boolean())
  })
});
var dropSchema = object({
  type: enumType(["sql-drop"]),
  schema: sch,
  data: object({
    table: string(),
    isCascade: optional(boolean())
  })
});
var schema = union([
  init,
  proxy,
  rawSqlQuery,
  tablesSchema,
  insertSchema,
  selectSchema,
  updateSchema,
  deleteSchema,
  truncateSchema,
  dropSchema
]);

// node_modules/.pnpm/superjson@2.2.1/node_modules/superjson/dist/double-indexed-kv.js
var DoubleIndexedKV = class {
  constructor() {
    this.keyToValue = /* @__PURE__ */ new Map();
    this.valueToKey = /* @__PURE__ */ new Map();
  }
  set(key, value) {
    this.keyToValue.set(key, value);
    this.valueToKey.set(value, key);
  }
  getByKey(key) {
    return this.keyToValue.get(key);
  }
  getByValue(value) {
    return this.valueToKey.get(value);
  }
  clear() {
    this.keyToValue.clear();
    this.valueToKey.clear();
  }
};

// node_modules/.pnpm/superjson@2.2.1/node_modules/superjson/dist/registry.js
var Registry = class {
  constructor(generateIdentifier) {
    this.generateIdentifier = generateIdentifier;
    this.kv = new DoubleIndexedKV();
  }
  register(value, identifier) {
    if (this.kv.getByValue(value)) {
      return;
    }
    if (!identifier) {
      identifier = this.generateIdentifier(value);
    }
    this.kv.set(identifier, value);
  }
  clear() {
    this.kv.clear();
  }
  getIdentifier(value) {
    return this.kv.getByValue(value);
  }
  getValue(identifier) {
    return this.kv.getByKey(identifier);
  }
};

// node_modules/.pnpm/superjson@2.2.1/node_modules/superjson/dist/class-registry.js
var ClassRegistry = class extends Registry {
  constructor() {
    super((c) => c.name);
    this.classToAllowedProps = /* @__PURE__ */ new Map();
  }
  register(value, options) {
    if (typeof options === "object") {
      if (options.allowProps) {
        this.classToAllowedProps.set(value, options.allowProps);
      }
      super.register(value, options.identifier);
    } else {
      super.register(value, options);
    }
  }
  getAllowedProps(value) {
    return this.classToAllowedProps.get(value);
  }
};

// node_modules/.pnpm/superjson@2.2.1/node_modules/superjson/dist/util.js
function valuesOfObj(record2) {
  if ("values" in Object) {
    return Object.values(record2);
  }
  const values = [];
  for (const key in record2) {
    if (record2.hasOwnProperty(key)) {
      values.push(record2[key]);
    }
  }
  return values;
}
function find(record2, predicate) {
  const values = valuesOfObj(record2);
  if ("find" in values) {
    return values.find(predicate);
  }
  const valuesNotNever = values;
  for (let i = 0; i < valuesNotNever.length; i++) {
    const value = valuesNotNever[i];
    if (predicate(value)) {
      return value;
    }
  }
  return void 0;
}
function forEach(record2, run) {
  Object.entries(record2).forEach(([key, value]) => run(value, key));
}
function includes(arr, value) {
  return arr.indexOf(value) !== -1;
}
function findArr(record2, predicate) {
  for (let i = 0; i < record2.length; i++) {
    const value = record2[i];
    if (predicate(value)) {
      return value;
    }
  }
  return void 0;
}

// node_modules/.pnpm/superjson@2.2.1/node_modules/superjson/dist/custom-transformer-registry.js
var CustomTransformerRegistry = class {
  constructor() {
    this.transfomers = {};
  }
  register(transformer) {
    this.transfomers[transformer.name] = transformer;
  }
  findApplicable(v) {
    return find(this.transfomers, (transformer) => transformer.isApplicable(v));
  }
  findByName(name) {
    return this.transfomers[name];
  }
};

// node_modules/.pnpm/superjson@2.2.1/node_modules/superjson/dist/is.js
var getType = (payload) => Object.prototype.toString.call(payload).slice(8, -1);
var isUndefined = (payload) => typeof payload === "undefined";
var isNull = (payload) => payload === null;
var isPlainObject = (payload) => {
  if (typeof payload !== "object" || payload === null)
    return false;
  if (payload === Object.prototype)
    return false;
  if (Object.getPrototypeOf(payload) === null)
    return true;
  return Object.getPrototypeOf(payload) === Object.prototype;
};
var isEmptyObject = (payload) => isPlainObject(payload) && Object.keys(payload).length === 0;
var isArray = (payload) => Array.isArray(payload);
var isString = (payload) => typeof payload === "string";
var isNumber = (payload) => typeof payload === "number" && !isNaN(payload);
var isBoolean = (payload) => typeof payload === "boolean";
var isRegExp = (payload) => payload instanceof RegExp;
var isMap = (payload) => payload instanceof Map;
var isSet = (payload) => payload instanceof Set;
var isSymbol = (payload) => getType(payload) === "Symbol";
var isDate = (payload) => payload instanceof Date && !isNaN(payload.valueOf());
var isError = (payload) => payload instanceof Error;
var isNaNValue = (payload) => typeof payload === "number" && isNaN(payload);
var isPrimitive = (payload) => isBoolean(payload) || isNull(payload) || isUndefined(payload) || isNumber(payload) || isString(payload) || isSymbol(payload);
var isBigint = (payload) => typeof payload === "bigint";
var isInfinite = (payload) => payload === Infinity || payload === -Infinity;
var isTypedArray = (payload) => ArrayBuffer.isView(payload) && !(payload instanceof DataView);
var isURL = (payload) => payload instanceof URL;

// node_modules/.pnpm/superjson@2.2.1/node_modules/superjson/dist/pathstringifier.js
var escapeKey = (key) => key.replace(/\./g, "\\.");
var stringifyPath = (path) => path.map(String).map(escapeKey).join(".");
var parsePath = (string2) => {
  const result = [];
  let segment = "";
  for (let i = 0; i < string2.length; i++) {
    let char = string2.charAt(i);
    const isEscapedDot = char === "\\" && string2.charAt(i + 1) === ".";
    if (isEscapedDot) {
      segment += ".";
      i++;
      continue;
    }
    const isEndOfSegment = char === ".";
    if (isEndOfSegment) {
      result.push(segment);
      segment = "";
      continue;
    }
    segment += char;
  }
  const lastSegment = segment;
  result.push(lastSegment);
  return result;
};

// node_modules/.pnpm/superjson@2.2.1/node_modules/superjson/dist/transformer.js
function simpleTransformation(isApplicable, annotation, transform, untransform) {
  return {
    isApplicable,
    annotation,
    transform,
    untransform
  };
}
var simpleRules = [
  simpleTransformation(isUndefined, "undefined", () => null, () => void 0),
  simpleTransformation(isBigint, "bigint", (v) => v.toString(), (v) => {
    if (typeof BigInt !== "undefined") {
      return BigInt(v);
    }
    console.error("Please add a BigInt polyfill.");
    return v;
  }),
  simpleTransformation(isDate, "Date", (v) => v.toISOString(), (v) => new Date(v)),
  simpleTransformation(isError, "Error", (v, superJson) => {
    const baseError = {
      name: v.name,
      message: v.message
    };
    superJson.allowedErrorProps.forEach((prop) => {
      baseError[prop] = v[prop];
    });
    return baseError;
  }, (v, superJson) => {
    const e = new Error(v.message);
    e.name = v.name;
    e.stack = v.stack;
    superJson.allowedErrorProps.forEach((prop) => {
      e[prop] = v[prop];
    });
    return e;
  }),
  simpleTransformation(isRegExp, "regexp", (v) => "" + v, (regex) => {
    const body = regex.slice(1, regex.lastIndexOf("/"));
    const flags = regex.slice(regex.lastIndexOf("/") + 1);
    return new RegExp(body, flags);
  }),
  simpleTransformation(
    isSet,
    "set",
    // (sets only exist in es6+)
    // eslint-disable-next-line es5/no-es6-methods
    (v) => [...v.values()],
    (v) => new Set(v)
  ),
  simpleTransformation(isMap, "map", (v) => [...v.entries()], (v) => new Map(v)),
  simpleTransformation((v) => isNaNValue(v) || isInfinite(v), "number", (v) => {
    if (isNaNValue(v)) {
      return "NaN";
    }
    if (v > 0) {
      return "Infinity";
    } else {
      return "-Infinity";
    }
  }, Number),
  simpleTransformation((v) => v === 0 && 1 / v === -Infinity, "number", () => {
    return "-0";
  }, Number),
  simpleTransformation(isURL, "URL", (v) => v.toString(), (v) => new URL(v))
];
function compositeTransformation(isApplicable, annotation, transform, untransform) {
  return {
    isApplicable,
    annotation,
    transform,
    untransform
  };
}
var symbolRule = compositeTransformation((s, superJson) => {
  if (isSymbol(s)) {
    const isRegistered = !!superJson.symbolRegistry.getIdentifier(s);
    return isRegistered;
  }
  return false;
}, (s, superJson) => {
  const identifier = superJson.symbolRegistry.getIdentifier(s);
  return ["symbol", identifier];
}, (v) => v.description, (_, a, superJson) => {
  const value = superJson.symbolRegistry.getValue(a[1]);
  if (!value) {
    throw new Error("Trying to deserialize unknown symbol");
  }
  return value;
});
var constructorToName = [
  Int8Array,
  Uint8Array,
  Int16Array,
  Uint16Array,
  Int32Array,
  Uint32Array,
  Float32Array,
  Float64Array,
  Uint8ClampedArray
].reduce((obj, ctor) => {
  obj[ctor.name] = ctor;
  return obj;
}, {});
var typedArrayRule = compositeTransformation(isTypedArray, (v) => ["typed-array", v.constructor.name], (v) => [...v], (v, a) => {
  const ctor = constructorToName[a[1]];
  if (!ctor) {
    throw new Error("Trying to deserialize unknown typed array");
  }
  return new ctor(v);
});
function isInstanceOfRegisteredClass(potentialClass, superJson) {
  if (potentialClass?.constructor) {
    const isRegistered = !!superJson.classRegistry.getIdentifier(potentialClass.constructor);
    return isRegistered;
  }
  return false;
}
var classRule = compositeTransformation(isInstanceOfRegisteredClass, (clazz, superJson) => {
  const identifier = superJson.classRegistry.getIdentifier(clazz.constructor);
  return ["class", identifier];
}, (clazz, superJson) => {
  const allowedProps = superJson.classRegistry.getAllowedProps(clazz.constructor);
  if (!allowedProps) {
    return { ...clazz };
  }
  const result = {};
  allowedProps.forEach((prop) => {
    result[prop] = clazz[prop];
  });
  return result;
}, (v, a, superJson) => {
  const clazz = superJson.classRegistry.getValue(a[1]);
  if (!clazz) {
    throw new Error("Trying to deserialize unknown class - check https://github.com/blitz-js/superjson/issues/116#issuecomment-773996564");
  }
  return Object.assign(Object.create(clazz.prototype), v);
});
var customRule = compositeTransformation((value, superJson) => {
  return !!superJson.customTransformerRegistry.findApplicable(value);
}, (value, superJson) => {
  const transformer = superJson.customTransformerRegistry.findApplicable(value);
  return ["custom", transformer.name];
}, (value, superJson) => {
  const transformer = superJson.customTransformerRegistry.findApplicable(value);
  return transformer.serialize(value);
}, (v, a, superJson) => {
  const transformer = superJson.customTransformerRegistry.findByName(a[1]);
  if (!transformer) {
    throw new Error("Trying to deserialize unknown custom value");
  }
  return transformer.deserialize(v);
});
var compositeRules = [classRule, symbolRule, customRule, typedArrayRule];
var transformValue = (value, superJson) => {
  const applicableCompositeRule = findArr(compositeRules, (rule) => rule.isApplicable(value, superJson));
  if (applicableCompositeRule) {
    return {
      value: applicableCompositeRule.transform(value, superJson),
      type: applicableCompositeRule.annotation(value, superJson)
    };
  }
  const applicableSimpleRule = findArr(simpleRules, (rule) => rule.isApplicable(value, superJson));
  if (applicableSimpleRule) {
    return {
      value: applicableSimpleRule.transform(value, superJson),
      type: applicableSimpleRule.annotation
    };
  }
  return void 0;
};
var simpleRulesByAnnotation = {};
simpleRules.forEach((rule) => {
  simpleRulesByAnnotation[rule.annotation] = rule;
});
var untransformValue = (json, type, superJson) => {
  if (isArray(type)) {
    switch (type[0]) {
      case "symbol":
        return symbolRule.untransform(json, type, superJson);
      case "class":
        return classRule.untransform(json, type, superJson);
      case "custom":
        return customRule.untransform(json, type, superJson);
      case "typed-array":
        return typedArrayRule.untransform(json, type, superJson);
      default:
        throw new Error("Unknown transformation: " + type);
    }
  } else {
    const transformation = simpleRulesByAnnotation[type];
    if (!transformation) {
      throw new Error("Unknown transformation: " + type);
    }
    return transformation.untransform(json, superJson);
  }
};

// node_modules/.pnpm/superjson@2.2.1/node_modules/superjson/dist/accessDeep.js
var getNthKey = (value, n) => {
  const keys = value.keys();
  while (n > 0) {
    keys.next();
    n--;
  }
  return keys.next().value;
};
function validatePath(path) {
  if (includes(path, "__proto__")) {
    throw new Error("__proto__ is not allowed as a property");
  }
  if (includes(path, "prototype")) {
    throw new Error("prototype is not allowed as a property");
  }
  if (includes(path, "constructor")) {
    throw new Error("constructor is not allowed as a property");
  }
}
var getDeep = (object2, path) => {
  validatePath(path);
  for (let i = 0; i < path.length; i++) {
    const key = path[i];
    if (isSet(object2)) {
      object2 = getNthKey(object2, +key);
    } else if (isMap(object2)) {
      const row = +key;
      const type = +path[++i] === 0 ? "key" : "value";
      const keyOfRow = getNthKey(object2, row);
      switch (type) {
        case "key":
          object2 = keyOfRow;
          break;
        case "value":
          object2 = object2.get(keyOfRow);
          break;
      }
    } else {
      object2 = object2[key];
    }
  }
  return object2;
};
var setDeep = (object2, path, mapper) => {
  validatePath(path);
  if (path.length === 0) {
    return mapper(object2);
  }
  let parent = object2;
  for (let i = 0; i < path.length - 1; i++) {
    const key = path[i];
    if (isArray(parent)) {
      const index = +key;
      parent = parent[index];
    } else if (isPlainObject(parent)) {
      parent = parent[key];
    } else if (isSet(parent)) {
      const row = +key;
      parent = getNthKey(parent, row);
    } else if (isMap(parent)) {
      const isEnd = i === path.length - 2;
      if (isEnd) {
        break;
      }
      const row = +key;
      const type = +path[++i] === 0 ? "key" : "value";
      const keyOfRow = getNthKey(parent, row);
      switch (type) {
        case "key":
          parent = keyOfRow;
          break;
        case "value":
          parent = parent.get(keyOfRow);
          break;
      }
    }
  }
  const lastKey = path[path.length - 1];
  if (isArray(parent)) {
    parent[+lastKey] = mapper(parent[+lastKey]);
  } else if (isPlainObject(parent)) {
    parent[lastKey] = mapper(parent[lastKey]);
  }
  if (isSet(parent)) {
    const oldValue = getNthKey(parent, +lastKey);
    const newValue = mapper(oldValue);
    if (oldValue !== newValue) {
      parent.delete(oldValue);
      parent.add(newValue);
    }
  }
  if (isMap(parent)) {
    const row = +path[path.length - 2];
    const keyToRow = getNthKey(parent, row);
    const type = +lastKey === 0 ? "key" : "value";
    switch (type) {
      case "key": {
        const newKey = mapper(keyToRow);
        parent.set(newKey, parent.get(keyToRow));
        if (newKey !== keyToRow) {
          parent.delete(keyToRow);
        }
        break;
      }
      case "value": {
        parent.set(keyToRow, mapper(parent.get(keyToRow)));
        break;
      }
    }
  }
  return object2;
};

// node_modules/.pnpm/superjson@2.2.1/node_modules/superjson/dist/plainer.js
function traverse(tree, walker2, origin = []) {
  if (!tree) {
    return;
  }
  if (!isArray(tree)) {
    forEach(tree, (subtree, key) => traverse(subtree, walker2, [...origin, ...parsePath(key)]));
    return;
  }
  const [nodeValue, children] = tree;
  if (children) {
    forEach(children, (child, key) => {
      traverse(child, walker2, [...origin, ...parsePath(key)]);
    });
  }
  walker2(nodeValue, origin);
}
function applyValueAnnotations(plain, annotations, superJson) {
  traverse(annotations, (type, path) => {
    plain = setDeep(plain, path, (v) => untransformValue(v, type, superJson));
  });
  return plain;
}
function applyReferentialEqualityAnnotations(plain, annotations) {
  function apply(identicalPaths, path) {
    const object2 = getDeep(plain, parsePath(path));
    identicalPaths.map(parsePath).forEach((identicalObjectPath) => {
      plain = setDeep(plain, identicalObjectPath, () => object2);
    });
  }
  if (isArray(annotations)) {
    const [root, other] = annotations;
    root.forEach((identicalPath) => {
      plain = setDeep(plain, parsePath(identicalPath), () => plain);
    });
    if (other) {
      forEach(other, apply);
    }
  } else {
    forEach(annotations, apply);
  }
  return plain;
}
var isDeep = (object2, superJson) => isPlainObject(object2) || isArray(object2) || isMap(object2) || isSet(object2) || isInstanceOfRegisteredClass(object2, superJson);
function addIdentity(object2, path, identities) {
  const existingSet = identities.get(object2);
  if (existingSet) {
    existingSet.push(path);
  } else {
    identities.set(object2, [path]);
  }
}
function generateReferentialEqualityAnnotations(identitites, dedupe) {
  const result = {};
  let rootEqualityPaths = void 0;
  identitites.forEach((paths) => {
    if (paths.length <= 1) {
      return;
    }
    if (!dedupe) {
      paths = paths.map((path) => path.map(String)).sort((a, b) => a.length - b.length);
    }
    const [representativePath, ...identicalPaths] = paths;
    if (representativePath.length === 0) {
      rootEqualityPaths = identicalPaths.map(stringifyPath);
    } else {
      result[stringifyPath(representativePath)] = identicalPaths.map(stringifyPath);
    }
  });
  if (rootEqualityPaths) {
    if (isEmptyObject(result)) {
      return [rootEqualityPaths];
    } else {
      return [rootEqualityPaths, result];
    }
  } else {
    return isEmptyObject(result) ? void 0 : result;
  }
}
var walker = (object2, identities, superJson, dedupe, path = [], objectsInThisPath = [], seenObjects = /* @__PURE__ */ new Map()) => {
  const primitive = isPrimitive(object2);
  if (!primitive) {
    addIdentity(object2, path, identities);
    const seen = seenObjects.get(object2);
    if (seen) {
      return dedupe ? {
        transformedValue: null
      } : seen;
    }
  }
  if (!isDeep(object2, superJson)) {
    const transformed2 = transformValue(object2, superJson);
    const result2 = transformed2 ? {
      transformedValue: transformed2.value,
      annotations: [transformed2.type]
    } : {
      transformedValue: object2
    };
    if (!primitive) {
      seenObjects.set(object2, result2);
    }
    return result2;
  }
  if (includes(objectsInThisPath, object2)) {
    return {
      transformedValue: null
    };
  }
  const transformationResult = transformValue(object2, superJson);
  const transformed = transformationResult?.value ?? object2;
  const transformedValue = isArray(transformed) ? [] : {};
  const innerAnnotations = {};
  forEach(transformed, (value, index) => {
    if (index === "__proto__" || index === "constructor" || index === "prototype") {
      throw new Error(`Detected property ${index}. This is a prototype pollution risk, please remove it from your object.`);
    }
    const recursiveResult = walker(value, identities, superJson, dedupe, [...path, index], [...objectsInThisPath, object2], seenObjects);
    transformedValue[index] = recursiveResult.transformedValue;
    if (isArray(recursiveResult.annotations)) {
      innerAnnotations[index] = recursiveResult.annotations;
    } else if (isPlainObject(recursiveResult.annotations)) {
      forEach(recursiveResult.annotations, (tree, key) => {
        innerAnnotations[escapeKey(index) + "." + key] = tree;
      });
    }
  });
  const result = isEmptyObject(innerAnnotations) ? {
    transformedValue,
    annotations: !!transformationResult ? [transformationResult.type] : void 0
  } : {
    transformedValue,
    annotations: !!transformationResult ? [transformationResult.type, innerAnnotations] : innerAnnotations
  };
  if (!primitive) {
    seenObjects.set(object2, result);
  }
  return result;
};

// node_modules/.pnpm/is-what@4.1.16/node_modules/is-what/dist/index.js
function getType2(payload) {
  return Object.prototype.toString.call(payload).slice(8, -1);
}
function isArray2(payload) {
  return getType2(payload) === "Array";
}
function isPlainObject2(payload) {
  if (getType2(payload) !== "Object")
    return false;
  const prototype = Object.getPrototypeOf(payload);
  return !!prototype && prototype.constructor === Object && prototype === Object.prototype;
}
function isNull2(payload) {
  return getType2(payload) === "Null";
}
function isOneOf(a, b, c, d, e) {
  return (value) => a(value) || b(value) || !!c && c(value) || !!d && d(value) || !!e && e(value);
}
function isUndefined2(payload) {
  return getType2(payload) === "Undefined";
}
var isNullOrUndefined = isOneOf(isNull2, isUndefined2);

// node_modules/.pnpm/copy-anything@3.0.5/node_modules/copy-anything/dist/index.js
function assignProp(carry, key, newVal, originalObject, includeNonenumerable) {
  const propType = {}.propertyIsEnumerable.call(originalObject, key) ? "enumerable" : "nonenumerable";
  if (propType === "enumerable")
    carry[key] = newVal;
  if (includeNonenumerable && propType === "nonenumerable") {
    Object.defineProperty(carry, key, {
      value: newVal,
      enumerable: false,
      writable: true,
      configurable: true
    });
  }
}
function copy(target, options = {}) {
  if (isArray2(target)) {
    return target.map((item) => copy(item, options));
  }
  if (!isPlainObject2(target)) {
    return target;
  }
  const props = Object.getOwnPropertyNames(target);
  const symbols = Object.getOwnPropertySymbols(target);
  return [...props, ...symbols].reduce((carry, key) => {
    if (isArray2(options.props) && !options.props.includes(key)) {
      return carry;
    }
    const val = target[key];
    const newVal = copy(val, options);
    assignProp(carry, key, newVal, target, options.nonenumerable);
    return carry;
  }, {});
}

// node_modules/.pnpm/superjson@2.2.1/node_modules/superjson/dist/index.js
var SuperJSON = class {
  /**
   * @param dedupeReferentialEqualities  If true, SuperJSON will make sure only one instance of referentially equal objects are serialized and the rest are replaced with `null`.
   */
  constructor({ dedupe = false } = {}) {
    this.classRegistry = new ClassRegistry();
    this.symbolRegistry = new Registry((s) => s.description ?? "");
    this.customTransformerRegistry = new CustomTransformerRegistry();
    this.allowedErrorProps = [];
    this.dedupe = dedupe;
  }
  serialize(object2) {
    const identities = /* @__PURE__ */ new Map();
    const output = walker(object2, identities, this, this.dedupe);
    const res = {
      json: output.transformedValue
    };
    if (output.annotations) {
      res.meta = {
        ...res.meta,
        values: output.annotations
      };
    }
    const equalityAnnotations = generateReferentialEqualityAnnotations(identities, this.dedupe);
    if (equalityAnnotations) {
      res.meta = {
        ...res.meta,
        referentialEqualities: equalityAnnotations
      };
    }
    return res;
  }
  deserialize(payload) {
    const { json, meta } = payload;
    let result = copy(json);
    if (meta?.values) {
      result = applyValueAnnotations(result, meta.values, this);
    }
    if (meta?.referentialEqualities) {
      result = applyReferentialEqualityAnnotations(result, meta.referentialEqualities);
    }
    return result;
  }
  stringify(object2) {
    return JSON.stringify(this.serialize(object2));
  }
  parse(string2) {
    return this.deserialize(JSON.parse(string2));
  }
  registerClass(v, options) {
    this.classRegistry.register(v, options);
  }
  registerSymbol(v, identifier) {
    this.symbolRegistry.register(v, identifier);
  }
  registerCustom(transformer, name) {
    this.customTransformerRegistry.register({
      name,
      ...transformer
    });
  }
  allowErrorProps(...props) {
    this.allowedErrorProps.push(...props);
  }
};
SuperJSON.defaultInstance = new SuperJSON();
SuperJSON.serialize = SuperJSON.defaultInstance.serialize.bind(SuperJSON.defaultInstance);
SuperJSON.deserialize = SuperJSON.defaultInstance.deserialize.bind(SuperJSON.defaultInstance);
SuperJSON.stringify = SuperJSON.defaultInstance.stringify.bind(SuperJSON.defaultInstance);
SuperJSON.parse = SuperJSON.defaultInstance.parse.bind(SuperJSON.defaultInstance);
SuperJSON.registerClass = SuperJSON.defaultInstance.registerClass.bind(SuperJSON.defaultInstance);
SuperJSON.registerSymbol = SuperJSON.defaultInstance.registerSymbol.bind(SuperJSON.defaultInstance);
SuperJSON.registerCustom = SuperJSON.defaultInstance.registerCustom.bind(SuperJSON.defaultInstance);
SuperJSON.allowErrorProps = SuperJSON.defaultInstance.allowErrorProps.bind(SuperJSON.defaultInstance);
var serialize2 = SuperJSON.serialize;
var deserialize = SuperJSON.deserialize;
var stringify = SuperJSON.stringify;
var parse2 = SuperJSON.parse;
var registerClass = SuperJSON.registerClass;
var registerCustom = SuperJSON.registerCustom;
var registerSymbol = SuperJSON.registerSymbol;
var allowErrorProps = SuperJSON.allowErrorProps;

// src/server.ts
var import_node_https = require("node:https");
SuperJSON.registerCustom(
  {
    isApplicable: (v) => v instanceof Buffer,
    serialize: (v) => [...v],
    deserialize: (v) => Buffer.from(v)
  },
  "buffer"
);
var jsonStringify = (data) => {
  return JSON.stringify(data, (_key, value) => {
    if (typeof value === "bigint") {
      return value.toString();
    }
    if (typeof value === "object" && value !== null && "type" in value && "data" in value && value.type === "Buffer") {
      return Buffer.from(value.data).toString("base64");
    }
    return value;
  });
};
var prepareServer = async (queryEngineProvider, app) => {
  app = app !== void 0 ? app : new Hono2();
  app.use(cors());
  app.onError((err) => {
    console.error(err);
    return new Response(
      JSON.stringify({
        status: "error",
        error: err.message
      }),
      {
        status: 200
      }
    );
  });
  app.get("/raw-sql", async (c) => {
    const qe = await queryEngineProvider(c);
  });
  app.post("/", (0, import_valibot_validator.vValidator)("json", schema), async (c) => {
    const {
      dialect,
      proxy: proxy2,
      raw,
      select,
      delete: del,
      insert,
      update,
      tables,
      schemas,
      relations,
      dropTable,
      truncate,
      ts
    } = await queryEngineProvider(c);
    const body = c.req.valid("json");
    const { type } = body;
    if (type === "init") {
      return c.json({ version: "3", dialect, schemas });
    }
    if (type === "proxy") {
      const result = await proxy2(body.data);
      return c.json(SuperJSON.serialize(result));
    }
    if (type === "raw-sql") {
      const res = await raw(body.data);
      return c.json(SuperJSON.serialize(res));
    }
    if (type === "sql-schema") {
      const count = body.data?.count ?? true;
      const res = await tables(body.schema, {
        withoutCount: !count
      });
      return c.json({ tables: res, relations, ts });
    }
    switch (type) {
      case "sql-insert": {
        const { table, data } = body.data;
        await insert(body.schema)({ table, data });
        return c.json({ status: "ok" });
      }
      case "sql-select": {
        const { table, columns, where, orderBy, limit, offset } = body.data;
        try {
          const result = await select(body.schema)({
            table,
            columns,
            where,
            orderBy,
            limit,
            offset
          });
          c.header("Content-Type", "application/json");
          c.status(200);
          return c.body(jsonStringify(result));
        } catch (e) {
          console.error("error", e);
          return c.json({ error: e.message }, 500);
        }
      }
      case "sql-update": {
        const { table, where, data } = body.data;
        await update(body.schema)({ table, where, data });
        return c.json({ status: "ok" });
      }
      case "sql-delete": {
        const { table, where } = body.data;
        await del(body.schema)({ table, where });
        return c.json({ status: "ok" });
      }
      case "sql-truncate": {
        const { table, isCascade } = body.data;
        await truncate(body.schema)({ table, isCascade });
        return c.json({ status: "ok" });
      }
      case "sql-drop": {
        const { table, isCascade } = body.data;
        await dropTable(body.schema)({ table, isCascade });
        return c.json({ status: "ok" });
      }
      default:
        throw new Error(`Unknown type: ${type}`);
    }
  });
  return {
    start: (params) => {
      serve(
        {
          fetch: app.fetch,
          createServer: params.key ? import_node_https.createServer : void 0,
          hostname: params.host,
          port: params.port,
          serverOptions: {
            key: params.key,
            cert: params.cert
          }
        },
        () => params.cb(null, `${params.host}:${params.port}`)
      );
    }
  };
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  prepareServer
});
//# sourceMappingURL=server.js.map
